#!/usr/bin/python
from __future__ import print_function

import argparse
import io
import itertools
import logging
import pprint
import threading
import tempfile
import os
import re
import shutil
import sys
import subprocess
import textwrap

VERSION = 0

GIT_CONFIG_FILE = 'config'
GGIT_FOLDER = 'git-svn'
GGIT_CONFIG_BRANCH =  'ggit-config'

NON_GIT_HEAD = textwrap.dedent('''
    The HEAD is not pointing to a git-svn branch.
    In order to setup a .svn folder switch branches with ggit:

        ggit switch <branch-name>

''')
DIRTY_WORKING = textwrap.dedent('''
Refusing to change branches, working directory is dirty.
Consider stashing changes:

    git stash --include-untracked

''')


python_version = sys.version_info
python_version = python_version[0]

if python_version <= 2:
    import ConfigParser as configparser
else:
    import configparser

class Chdir:
    def __init__(self, directory):
        self._dir = directory

    def __enter__(self):
        self._olddir = os.getcwd()
        os.chdir(self._dir)
        return self

    def __exit__(self, *args):
        if hasattr(self,'_olddir'):
            os.chdir(self._olddir)

class Status:
    NoConfigBranch = 1
    NotInRepo = 2
    PathExists = 3
    RepoIsDirty = 4
    AmbiguousReference = 5

    Error = 100

class GGitExcpetion(Exception):
    def __init__(self, status, msg=None):
        self.status = status
        Exception.__init__(self, msg)

class TemporaryDirectory(object):
    def __enter__(self):
        self.dir = tempfile.mkdtemp()
        return self

    def __exit__(self, *args):
        shutil.rmtree(self.dir)

def _preoprocess_call(*args, **kwargs):
    if python_version > 2:
            kwargs['universal_newlines'] = True

    if 'shell' not in kwargs:
        kwargs.setdefault('executable', 'bash')
        kwargs.setdefault('shell', True)

    kwargs.setdefault('stdout', subprocess.PIPE)
    kwargs.setdefault('stderr', subprocess.STDOUT)

    pprint.pprint(('Call: ', args, kwargs), stream=sys.stderr)
    return args, kwargs

def call_output(*args, **kwargs):
    if 'stdout' in kwargs:
        raise ValueError('stdout argument not allowed, it will be overridden.')
    args, kwargs = _preoprocess_call(*args, **kwargs)
    del kwargs['stdout']
    return subprocess.check_output(*args, **kwargs)

def check_call(*args, **kwargs):
    args, kwargs = _preoprocess_call(*args, **kwargs)
    return subprocess.check_call(*args, **kwargs)

def call_status(*args, **kwargs):
    args, kwargs = _preoprocess_call(*args, **kwargs)
    return subprocess.call(*args, **kwargs)

class Git:
    @staticmethod
    def staging_is_dirty():
        ret = call_status('git diff-index --cached --quiet HEAD --ignore-submodules --')
        return bool(ret)

    @staticmethod
    def working_is_dirty():
        ret = call_status('git ls-files --other --directory --exclude-standard'
                '| sed q1',
                shell=True)
        return not bool(ret)

    @staticmethod
    def is_dirty():
        return any((Git.staging_is_dirty(), Git.working_is_dirty()))

    @staticmethod
    def in_a_repo():
        try:
            Git.toplevel()
        except GGitExcpetion as e:
            return (False, e.msg)
        return (True, None)

    @staticmethod
    def enforce_in_repo():
        (status, msg) = Git.in_a_repo()
        if not status:
            raise GGitExcpetion(Status.NotInRepo, msg)

    @staticmethod
    def enforce_clean():
        if Git.is_dirty():
            raise GGitExcpetion(Status.RepoIsDirty, DIRTY_WORKING)

    @staticmethod
    def latest_svn_commit(hashish):
        '''
        Check the git log for the latest git-svn log entry. Return a GitSvnLogEntry
        object for the entry. If no such entry is found return None. 
        '''
        kwargs = { 
                'stdout': subprocess.PIPE,
                'stderr': None,
        }
        args = (('git log %s' % hashish).split(),)
        (args, kwargs) = _preoprocess_call(*args, **kwargs)

        git = subprocess.Popen(*args, **kwargs)
        line_iter = iter(git.stdout.readline, '')

        entry = None
        def get_entry(line_iter):
            global entry
            entry = GitSvnLogEntry.find_entry(line_iter)

        thread = threading.Thread(target=get_entry, args=(line_iter,))
        thread.start()
        git.communicate()
        thread.join()

        return entry

    @staticmethod
    def toplevel():
        try:
            output = call_output('git rev-parse --show-toplevel',
                    stderr=subprocess.PIPE).rstrip()
            return output
        except subprocess.CalledProcessError as e:
            raise GGitExcpetion(Status.NotInRepo, e.msg)

    @staticmethod
    def dot_git():
        return os.path.join(Git.toplevel(), '.git')

    @staticmethod
    def basename(repository):
        base = os.path.basename(respository)
        return re.sub(r'.git$', '', base)

    @staticmethod
    def find_config_branch():
        '''
        Check that the ggit-config branch exists locally or as a remote by looking
          in .git/refs/heads and .git/refs/remotes, if not local, but in multiple
          remotes fail.
        '''
        dot_git = Git.dot_git()

        def trim_path(path):
            common = os.path.commonprefix((dot_git, path))
            return path[len(common):].lstrip('/')

        matches = []
        for root, dirs, files in os.walk(os.path.join(dot_git, 'refs')):
            for f in files:
                name = os.path.basename(f)
                if name == GGIT_CONFIG_BRANCH:
                    matches.append(trim_path(os.path.join(root, f)))

        local_config_branch = 'refs/heads/' + GGIT_CONFIG_BRANCH

        if local_config_branch in matches:
            return local_config_branch
        if len(matches) > 1:
            raise GGitExcpetion(Status.AmbiguousReference)
        if matches:
            return matches[0]


class GitSvnConfig():
    template = '''
    [svn-remote "svn"]
        url = {url}
    {fetches}
    '''
    template = textwrap.dedent(template)
    fetch_template = ('    fetch = {remote_branch}:'
            'refs/remotes/svn/{folder}/{branch}')

    @classmethod
    def fill_template(cls, url, fetches):
        fetch_templates = []
        for (remote_branch, branch) in fetches:
            fetch_templates.append(cls.fetch_template.format(
                folder=GGIT_FOLDER,
                remote_branch=remote_branch,
                branch=branch))

        fetch_templates = '\n'.join(fetch_templates)
        return cls.template.format(url=url, folder=GGIT_FOLDER, 
                fetches=fetch_templates)

class Subcommand(object):
    @classmethod
    def _map_subcommand(cls, command):
        commands = {}
        for subclass in cls.__subclasses__():
            subcommand = subclass.__name__.lower()
            assert subcommand not in commands
            commands[subcommand] = subclass

        return commands[command.lower()]

    @classmethod
    def run_command(cls, command, args):
        subclass = cls._map_subcommand(command)
        return subclass().run(args)

    @classmethod
    def init_parsers(cls, subparsers):
        subclasses = cls.__subclasses__()
        for subclass in subclasses:
            subparser = subparsers.add_parser(subclass.__name__.lower(), 
                    help=subclass.__doc__)
            subclass().init_parser(subparser)

    def init_parser(self, parser):
        pass

    def run(self, args):
        raise NotImplemented


class Initialize(Subcommand):
    '''
    Fetch and initialize a ggit repo from an svn path.

    It's recommended to use this within a bare repo.
    '''
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)
        parser.add_argument('-r', '--revision', default='0')
        parser.add_argument('url')
        parser.add_argument('remote-names', nargs='+',
                help='E.g. branches/ap/trunk:aptrunk')

    def _parse_remotes(self, remotes):
        fetches = {}
        for item in remotes:
            match = re.search('([^:]+):([^:]+)', item)
            if not match:
                raise ValueError('Argument incorrect format')
            fetches[match.group(2)] = match.group(1)
        return fetches

    def run(self, args):
        url = args['url']
        remotes = args['remote-names']
        rev = args['revision']
        conf_branch = args['config_branch']

        #TODO Assert user has git-sn
        fetches = self._parse_remotes(remotes)

        Git.enforce_in_repo()
        # TODO Save the original HEAD so we can restore it.

        with Chdir(Git.toplevel()):
            # If branch already exists, just checkout naturally.
            if Git.find_config_branch() is not None:
                check_call('git checkout {branch}'.format(branch=conf_branch))
            else:
                check_call('git checkout --orphan {branch}'.format(branch=conf_branch))
            check_call('git reset')

            # Create our config file
            config = GGitConfig(url, fetches)
            config.write(GIT_CONFIG_FILE)

            # Check if the file is the same as the config if so, don't try
            # to commit.
            check_call('git add {config}'.format(config=GIT_CONFIG_FILE))
            if Git.staging_is_dirty():
                check_call('git commit -m "<ggit autocommit> Create config file"')
            else:
                check_call('git reset')

            Configure().run(args)
            check_call('git svn fetch -r {revision}:HEAD'.format(revision=rev))


class Push(Subcommand):
    '''
    Push git-svn branches and ggit-config to a remote.
    '''
    def init_parser(self, parser):
        parser.add_argument('remote')
        # Todo support partial push

    def run(self, args):
        remote = args['remote']

        Git.enforce_in_repo()

        # Read the ggitconfig for branch names
        check_call('git push {remote}'
                ' refs/remotes/svn/git-svn/*'
                ':refs/heads/git-svn/*'
                .format(remote=remote))

        local_ref = Git.find_config_branch()
        check_call('git push {remote} {local_ref}:refs/heads/{config_branch}'
                .format(local_ref=local_ref,
                    config_branch=GGIT_CONFIG_BRANCH,
                    remote=remote))
#
#
#class GenerateIgnore(Subcommand):
#    '''Generate an ignore file'''
#
#    def init_parser(self, parser):
#        # TODO Accept optional argument of gitignroe manual file
#        pass
#
#    @staticmethod
#    def get_externs():
#        # Get a list of svn externals
#        # (Parse svn st for externals)
#        externs = []
#        changelist = call_output('svn st')
#        for line in changelist.splitlines():
#            match = re.search(r'^\s*X\s*(.*)$', line)
#            if match:
#                externs.append(match.groups(0))
#        return externs
#
#    def run(self, args):
#        externs = self.get_externs()
#        svn_ignores = call_output('git svn show-ignore')
#        svn_ignores = filter(lambda string: not string.startswith('#'), svn_ignores.splitlines())
#        for line in sorted(set(externs) and set(svn_ignores)):
#            print(line)
#        return EXIT_CODE.SUCCESS


#######################################################

#######################################################

#######################################################

#######################################################

class GitSvnLogEntry:
    # git-svn-id: http://rtosvc/trunk/rtos@274190 d5d84855-3516-0410-9f1e-893281b4b339
    SVN_ENTRY_REGEX = re.compile(
            r'git-svn-id: (?P<url>[^@]+)@(?P<rev>\d+)'
            r' (?P<svn_uuid>[0-9a-z\-]+)')

    # commit 3505cb1adc010f7dcf18247846fe09d7353acb9c
    GIT_ENTRY_REGEX = re.compile('commit (?P<hash>[0-9a-z]+)')

    def __init__(self, url, rev, git_uuid, svn_uuid):
        self.url = url
        self.revision = rev
        self.git_hash = git_uuid
        self.git_svn_hash = svn_uuid

    @classmethod
    def find_entry(cls, line_iter):
        # Keep a running log of git hashes,
        # Since git hashes are before git-svn entries, once we find a git-svn
        # entry the most recent git hash goes with the svn entry.  
        for line in line_iter:
            git_match = cls.GIT_ENTRY_REGEX.match(line)
            svn_match = cls.SVN_ENTRY_REGEX.match(line)
            if git_match:
                git_uuid = git_match.groups(1)
            if svn_match:
                match = svn_match.groupsdict()
                match['git_uuid'] = git_uuid
                return GitSvnLogEntry(**match)
        return None


class GGitConfig():
    def __init__(self, url, branches):
        '''
        :param url: Base url of the svn respository
        :param branches: {branch: path} dictionary
        '''
        self.url = url
        self.branches = branches

    @classmethod
    def from_str(cls, string):
        parser = configparser.SafeConfigParser()
        fp = io.BytesIO(string)
        parser.readfp(fp)
        sections = parser.sections()

        # Find brach.
        branches = []
        for section in sections:
            match = re.match('branch\.(.*)', section)
            if match:
                branches.append((match.group(0), match.group(1)))

        paths = {}
        for (section, branch) in branches:
            path = parser.get(section, 'path')
            assert path
            paths[branch] = path

        url = parser.get('base', 'url')
        assert url
        return GGitConfig(url, paths)

    @classmethod
    def from_branch(cls, branch):
        try:
            config = call_output('git show %s:config' % branch).rstrip()
        except subprocess.CalledProcessError as e:
            raise GGitExcpetion(Status.Error, textwrap.dedent('''
                    Failed to "git show {branch}:config"
                    Does the branch exist and contain the config file?
                    '''.format(branch=branch)))
        return cls.from_str(config)

    @classmethod
    def from_dot_git(cls):
        with open(cls.get_config_path(), 'r') as f:
            config = f.read()
        return cls.from_str(config)

    def write(self, pathname):
        '''Write the config object to the given file pathname.'''
        parser = configparser.ConfigParser()
        parser.add_section('base')
        parser.set('base', 'url', self.url)

        for branch, path in self.branches.items():
            section = 'branch.' + branch
            parser.add_section(section)
            parser.set(section, 'path', path)

        with open(pathname, 'w') as f:
            parser.write(f)

    def branch_to_url(self, branch):
        fetch_path = self.branches[branch]
        return self.url + '/' + fetch_path

    def url_to_branch(self, url):
        '''Given the url, convert it to a branch.'''
        for branch, path  in self.branches.items():
            if url == self.url + '/' + path:
                return branch

    @staticmethod
    def get_dot_svn_path(branch):
        git = GGitConfig.get_ggit_path()
        return os.path.join(git, 'svn', branch)

    @staticmethod
    def get_ggit_path():
        git = Git.dot_git()
        return os.path.join(git, 'ggit')

    @staticmethod
    def get_config_path():
        git = Git.dot_git()
        return os.path.join(git, 'ggit', 'config')

    def switch_svn(self, url, rev):
        branch = self.url_to_bramch(url)
        # Replace the symlink .svn with one in .git/ggit/
        svn_path = self.get_dot_svn_path(branch)
        if os.path.exists('.svn'):
            os.remove('.svn')
        os.symlink(svn_path, '.svn')

        # Run svn update to set the revision and depth.
        check_call( 'svn update -q --force --accept working'
                ' --set-depth=infinity -r {rev}'
                ''.format(rev=rev))
        # Run svn revert to clean to a known svn state.
        check_call('svn revert -q -R .')

    def _backup_ggit(self):
        ggit = self.get_ggit_path()
        if not os.path.exists(ggit):
            os.mkdir(ggit)
        else:
            backups = os.path.join(ggit, 'backups')
            if not os.path.exists(backups):
                os.mkdir(backups)
            backup_dir = tempfile.mkdtemp(dir=backups)
            old_files = os.listdir(ggit)
            old_files = (os.path.join(ggit, f) for f in old_files if f != 'backups')
            for f in old_files:
                shutil.move(f, backup_dir)

    def setup_ggit(self):
        # Create a .git/ggit/ folder. 
        #   (Backup the previous contents if it exists.)
        self._backup_ggit()

        # Add .svn to the .git/info/exclude folder.
        git = Git.dot_git()
        exclude = os.path.join(git, 'info', 'exclude')
        check_call('echo .svn >> ' + exclude)

        config_path = self.get_config_path()
        self.write(config_path)

    def setup_git_svn(self):
        git = Git.dot_git()

        autogen_head = textwrap.dedent('''
        # {{ ggit:{version}
        # This section has been automatically modfied by ggit.
        # Take care when removing it
        '''.format(version=VERSION))

        autogen_tail = textwrap.dedent('''
        # }} ggit:{version} 
        '''.format(version=VERSION))

        head_re = re.compile(r'# *{ *ggit:\d+')
        tail_re = re.compile(r'# *} *ggit:\d+')

        # Setup the .git/config fetches based on ggit-config file
        #   (Possibly replacing old version. Use a begin and end statement to mark for
        #   easy scripting.)
        def remove_old_entry(fp):
            lines = []
            old_tail = old_head = None
            for idx, line in enumerate(fp):
                lines.append(line)
                if head_re.search(line):
                    if old_head is not None:
                        raise GGitExcpetion(Status.GitConfigError)
                    old_head = idx
                if tail_re.search(line):
                    if old_tail is not None:
                        raise GGitExcpetion(Status.GitConfigError)
                    old_tail = idx

            old_idx = (old_head, old_tail)
            if not all(old_idx) and any(old_idx):
                raise GGitExcpetion(Status.GitConfigError)
            if old_tail < old_head:
                raise GGitExcpetion(Status.GitConfigError)
            if old_head:
                lines = lines[:old_head] + lines[old_tail+1:]
                # rewind file, write lines from beginning
                fp.truncate(0)
                fp.seek(0, 0)
                if lines[-1] == '\n':
                    lines = lines[0:-1]
                fp.writelines(lines)

        def write_new_entry(fp):
            fetches = ((remote, branch) for (branch,remote) in 
                    self.branches.items())
            config = GitSvnConfig.fill_template(self.url, fetches)
            fp.write(autogen_head)
            fp.write(config)
            fp.write(autogen_tail)

        with open(os.path.join(git, 'config'), 'r+') as fp:
            remove_old_entry(fp)
            fp.seek(0, 2)
            write_new_entry(fp)

    def setup_empty_svn(self):
        for branch in self.branches:
            svn_path = self.get_dot_svn_path(branch)
            svn_url = self.branch_to_url(branch)
            if os.path.lexists(svn_path):
                shutil.rmtree(svn_path)

            with TemporaryDirectory() as td:
                check_call('svn co --depth=empty "{url}" "{tmpdir}"'
                        .format(url=svn_url, tmpdir=td.dir))
                shutil.copytree(os.path.join(td.dir, '.svn'), svn_path)


class Clone(Subcommand):
    def init_parser(self, parser):
        parser.add_argument('repository')
        parser.add_argument('directory', default=None)

    def run(self, args):
        repository = args['repository']
        directory = args['directory'] # optional
        ref = GGIT_CONFIG_BRANCH

        # Check that the remote has the ggit-config branch.
        ret = call_status('git ls-remote -q --exit-code {remote} {ref}'
                .format(remote=repository, ref=ref))
        if ret != 0:
            print("The repository '%s' does not ggit config branch '%s'"
                    % (repository, ref))
            raise GGitExcpetion(Status.NoConfigBranch)

        # If no local folder name provided, use git's naming scheme.
        if directory is None:
            directory = Git.basename(repository)

        if os.path.exists(directory):
            return Status(Status.PathExists)

        check_call('git clone {repo} {directory}'
                .format(repo=repository, directory=directory))

        with Chdir(directory):
            Configure().run(args)

            # Create local branches for all remote git-svn branches.
            check_call('git fetch origin'
                    ' refs/remotes/origin/git-svn/*'
                    ':refs/heads/git-svn/*')


class Switch(Subcommand):
    def init_parser(self, parser):
        pass

    def run(self, args):
        force = args['force']
        hashish = args['hashish']

        # Check that we are in a git repo.
        Git.enforce_in_repo()

        # Check that the working directory is clean.
        if Git.is_dirty() and not force:
            raise GGitExcpetion(Status.RepoIsDirty)

        # Search the log for latest git-svn commit
        log_entry = Git.latest_svn_commit(hashish)

        # Check the .git/ggit/config file for the remote to .svn mapping.
        config = GGitConfig.from_dot_git()
        config.switch_svn(log_entry.url, log_entry.revision)

        # Run git checkout to complete head change.
        check_call('git checkout ' + hashish)


class Configure(Subcommand):
    def init_parser(self, parser):
        pass

    def run(self, args):
        '''
        Read from the ggit-config branch and configure the git repository to match.
        '''
        # Check that we are in a git repo.
        Git.enforce_in_repo()

        branch = Git.find_config_branch()
        config = GGitConfig.from_branch(branch)

        # Create a .git/ggit/ folder. 
        #   (Backup the previous contents if it exists.)
        # Add .svn to the .git/info/exclude folder.
        config.setup_ggit()

        # Setup the .git/config fetches based on ggit-config file
        #   (Possibly replacing old version. Use a begin and end statement to mark for
        #   easy scripting.)
        # Run git svn fetch
        config.setup_git_svn()

        # Prepare the --depth=empty .svn folders within the .git/ggit/ folder
        config.setup_empty_svn()

        # Check if the current HEAD is a git svn branch. 
        log_entry = Git.latest_svn_commit('HEAD')
        if log_entry is None:
            print(NON_GIT_HEAD)
        else:
            config.switch_svn(log_entry.url, log_entry.revision)

# TODO Command to create a gcrucible diff
# TODO Command to initialize a new repository with svn url and branches. (REQ)
# TODO Command to automate updating a repository with git-svn data (REQ)

def parse_args():
    parser = argparse.ArgumentParser(prog='ggit')
    subparsers = parser.add_subparsers(dest='command')
    Subcommand.init_parsers(subparsers)
    options = parser.parse_args()
    return options.command, vars(options)

def main(command, args):
    # TODO Assert user had git-svn installed.
    # Check the subparser used, pass the args to the class named after it.
    Subcommand.run_command(command, args)
    return 0

if __name__ == '__main__':
    parsed = parse_args()
    sys.exit(main(*parsed))
