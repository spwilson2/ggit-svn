#!/usr/bin/python
from __future__ import print_function

import argparse
import os
import pprint
import re
import shutil
import subprocess
import sys
import tempfile
import textwrap
import threading

VERSION = 0

GIT_CONFIG_FILE = 'config'
GIT_SVN_PFX = 'svn/'
GGIT_CONFIG_BRANCH = 'ggit-config'

NON_GIT_HEAD = textwrap.dedent('''
    The HEAD is not pointing to a git-svn branch.

    In order to setup a .svn folder, switch branches with ggit:

        ggit switch <branch-name>

''')
DIRTY_WORKING = textwrap.dedent('''
Refusing to change branches, working directory is dirty.

Consider stashing changes:

    git stash --include-untracked

''')

REMOTE_TYPES = {
    'file:///',
    'http://',
    'git://',
    'svn://',
    'ssh://',
}

python_version = sys.version_info
python_version = python_version[0]


class Chdir:
    def __init__(self, directory):
        self._dir = directory

    def __enter__(self):
        self._olddir = os.getcwd()
        os.chdir(self._dir)
        return self

    def __exit__(self, *args):
        if hasattr(self, '_olddir'):
            os.chdir(self._olddir)


class Status:
    NoConfigBranch = 1
    NotInRepo = 2
    PathExists = 3
    RepoIsDirty = 4
    AmbiguousReference = 5
    NoSuchCommit = 6
    NonSvnCommit = 7
    InvalidArguments = 8
    Error = 100


class GGitExcpetion(Exception):
    def __init__(self, status, msg=None):
        self.status = status
        Exception.__init__(self, msg)


class TemporaryDirectory(object):
    def __enter__(self):
        self.dir = tempfile.mkdtemp()
        return self

    def __exit__(self, *args):
        shutil.rmtree(self.dir)


def _preoprocess_call(*args, **kwargs):
    if python_version > 2:
            kwargs['universal_newlines'] = True

    if 'shell' not in kwargs:
        kwargs.setdefault('executable', 'bash')
        kwargs.setdefault('shell', True)

    kwargs.setdefault('stdout', subprocess.PIPE)
    kwargs.setdefault('stderr', subprocess.STDOUT)

    # pprint.pprint(('Call: ', args, kwargs), stream=sys.stderr)
    return args, kwargs


def call_output(*args, **kwargs):
    if 'stdout' in kwargs:
        raise ValueError('stdout argument not allowed, it will be overridden.')
    args, kwargs = _preoprocess_call(*args, **kwargs)
    del kwargs['stdout']
    return subprocess.check_output(*args, **kwargs)


def forward_check_call(*args, **kwargs):
    kwargs.setdefault('stdout', None)
    kwargs.setdefault('stderr', None)
    args, kwargs = _preoprocess_call(*args, **kwargs)
    print()
    print('>> ' + args[0])
    print()
    return subprocess.check_call(*args, **kwargs)


def check_call(*args, **kwargs):
    args, kwargs = _preoprocess_call(*args, **kwargs)
    return subprocess.check_call(*args, **kwargs)


def call_status(*args, **kwargs):
    args, kwargs = _preoprocess_call(*args, **kwargs)
    return subprocess.call(*args, **kwargs)


###############################################################################
#
# Lower level git utilities
#
###############################################################################


class Git:
    UUID_RE = '[0-9a-z]'

    @staticmethod
    def staging_is_dirty():
        ret = call_status('git diff --cached --quiet --ignore-submodules --')
        return bool(ret)

    @staticmethod
    def working_is_dirty():
        ret = call_status('git ls-files --other --directory --exclude-standard'
                          '| sed q1',
                          shell=True)
        return bool(ret)

    @staticmethod
    def ref_exists_on_remote(remote, ref):
        ret = call_status('git ls-remote -q --exit-code {remote} {ref}'
                          .format(remote=remote, ref=ref))
        return not bool(ret)

    @staticmethod
    def is_dirty():
        return any((Git.staging_is_dirty(), Git.working_is_dirty()))

    @staticmethod
    def in_a_repo():
        try:
            Git.toplevel()
        except GGitExcpetion as e:
            return (False, e.msg)
        return (True, None)

    @staticmethod
    def enforce_in_repo():
        (status, msg) = Git.in_a_repo()
        if not status:
            raise GGitExcpetion(Status.NotInRepo, msg)

    @staticmethod
    def enforce_clean():
        if Git.is_dirty():
            raise GGitExcpetion(Status.RepoIsDirty, DIRTY_WORKING)

    @staticmethod
    def list_heads():
        remotes = call_output('git remote show -n')
        remotes = remotes.splitlines()

        heads = {remote:[] for remote in remotes}
        for remote in remotes:
            refs = call_output('git ls-remote %s' % remote)
            for line in refs.splitlines():
                if line:
                    # <hash>	<ref>
                    _, ref = line.split()
                    ref = Git.branch_without_refs(ref)
                    heads[remote].append(ref)
        local = call_output('git branch')
        for line in local.splitlines():
            if line:
                heads[None] = line
        return heads

    @staticmethod
    def commit_exists(hashish):
        ret = call_status('git cat-file -e {hashish}^{{commit}}'
                          .format(hashish=hashish))
        return not bool(ret)

    @staticmethod
    def branch_without_refs(branch):
        heads = 'refs/heads/'
        if branch.startswith(heads):
            return branch[len(heads):]
        remotes = 'refs/remotes/'
        if branch.startswith(remotes):
            return branch[len(remotes):]
        return branch

    @staticmethod
    def latest_svn_commit(hashish):
        '''
        Check the git log for the latest git-svn log entry. Return
        a GitSvnLogEntry object for the entry. If no such entry is found return
        None.
        '''
        kwargs = {
                'stdout': subprocess.PIPE,
                'stderr': subprocess.PIPE,
                'shell': False,
        }
        args = (('git log %s' % hashish).split(),)
        (args, kwargs) = _preoprocess_call(*args, **kwargs)

        git = subprocess.Popen(*args, **kwargs)
        line_iter = iter(git.stdout.readline, '')

        entry = [None]  # Use a mutable object so thread can mutate it.

        def get_entry(line_iter, entry_list):
            entry_list[0] = GitSvnLogEntry.find_entry(line_iter)

        thread = threading.Thread(target=get_entry, args=(line_iter, entry))
        thread.start()
        thread.join()
        git.communicate()

        return entry[0]

    @staticmethod
    def toplevel():
        try:
            output = call_output('git rev-parse --show-toplevel',
                                 stderr=subprocess.PIPE).rstrip()
            return output
        except subprocess.CalledProcessError as e:
            raise GGitExcpetion(Status.NotInRepo, e.msg)

    @staticmethod
    def dot_git():
        return os.path.join(Git.toplevel(), '.git')

    @staticmethod
    def basename(repo):
        if repo.endswith('.git'):
            repo = repo[:len(repo) - len('.git')]
        repo = repo.rstrip('/')
        base = os.path.basename(repo)
        return re.sub(r'.git$', '', base)

    @staticmethod
    def find_branch(search):
        '''
        Check that the branch exists locally or as a remote by if not local,
        but in multiple remotes fail.
        '''
        remote_heads = Git.list_heads()
        matches = []
        for remote, heads in remote_heads.items():
            for head in heads:
                if head == search:
                    if remote is not None:
                        head = os.path.join(remote, head)
                    matches.append(head)

        if search in matches:
            return search
        if len(matches) > 1:
            raise GGitExcpetion(Status.AmbiguousReference,
                                ', '.join(matches))
        if matches:
            return matches[0]


class GitSvnLogEntry:
    # git-svn-id: \
    # http://rtosvc/trunk/rtos@274190 d5d84855-3516-0410-9f1e-893281b4b339
    SVN_ENTRY_REGEX = re.compile(
            r'\s*git-svn-id:\s+(?P<url>[^@]+)@(?P<rev>\d+)'
            r'\s+(?P<svn_uuid>[0-9a-z\-]+)')

    # commit 3505cb1adc010f7dcf18247846fe09d7353acb9c
    GIT_ENTRY_REGEX = re.compile('commit (?P<hash>[0-9a-z]+)')

    def __init__(self, url, rev, git_uuid, svn_uuid):
        self.url = url
        self.revision = rev
        self.git_hash = git_uuid
        self.git_svn_hash = svn_uuid

    @classmethod
    def find_entry(cls, line_iter):
        # Keep a running log of git hashes,
        # Since git hashes are before git-svn entries, once we find a git-svn
        # entry the most recent git hash goes with the svn entry.
        for line in line_iter:
            git_match = cls.GIT_ENTRY_REGEX.match(line)
            svn_match = cls.SVN_ENTRY_REGEX.match(line)
            if git_match:
                git_uuid = git_match.groups(1)
            if svn_match:
                match = svn_match.groupdict()
                match['git_uuid'] = git_uuid
                return GitSvnLogEntry(**match)
        return None


###############################################################################
#
# Config file items
#
###############################################################################


class GitSvnRemote():
    template = '''
    [svn-remote "{name}"]
    \turl = {url}
    {fetches}
    '''
    template = textwrap.dedent(template)
    fetch_template = ('\tfetch = {path}:{ref}')

    def __init__(self, name, url, fetches):
        '''
        :param url:
            Url of the svn remote to pull both git-svn and svn updates from
        :param fetches:
            A (path, ref) tuple used to configure git-svn fetching.
        '''
        self.name = name
        self.url = url

        self.fetches = []
        self.branches = []
        self.urls = []

        for fetch in fetches:
            (path, fetch_ref) = fetch.split(':')
            self.fetches.append((path, fetch_ref))

            # TODO Do I want to remove refs/(heads)|(remotes)/
            # from branch name?
            self.branches.append(fetch_ref)
            self.urls.append(os.path.join(url, path))

    def __str__(self):
        fetch_templates = []
        for (path, ref) in self.fetches:
            fetch_templates.append(self.fetch_template.format(
                path=path, ref=ref))

        fetch_templates = '\n'.join(fetch_templates)
        return self.template.format(url=self.url, name=self.name,
                                    fetches=fetch_templates)


class ConfigParserException(Exception):
    pass


class GitConfigParser(object):
    _COMMENT_RE = re.compile(r'[^#](?P<comment>#.*)$')
    _SECTION_RE = re.compile(r'\s*\[(?P<section>[^\]]*)\]')
    _ELEMENT_RE = re.compile(r'\s*(?P<key>[^=\s]*)\s*'
                             r'=\s*(?P<val>[^=\s]*)\s*')

    def __init__(self):
        '''
        Options format: {section: {key: [values, ...]} }
        '''
        self.parsed_options = {}

    def __str__(self):
        lines = []
        for section, opt_keys in self.parsed_options.items():
            lines.append('[%s]' % section)
            for key, values in opt_keys:
                for value in values:
                    lines.append('%s = %s' % (key, value))
        return '\n'.join(lines)

    def sections(self):
        return iter(self.parsed_options)

    def get(self, section, key):
        section_map = self.parsed_options.get(section)
        if section_map is None:
            raise ValueError('Not such section: "%s"'
                             '\n Avaliable sections: %s'
                             % (section, list(self.sections())))
        values = section_map.get(key)
        return values

    @classmethod
    def from_string(cls, string):
        self = GitConfigParser()
        new_string = []
        # Remove comments
        for line in string.splitlines():
            new_string.append(self._COMMENT_RE.sub('', line))

        # Assert that the section starts before an element
        for line in new_string:
            if self._SECTION_RE.search(line):
                break
            match = self._ELEMENT_RE.search(line)
            if match:
                raise ConfigParserException(
                    '%s\nElement not inside section' % match.group(0))

        cur_section = None
        for line in new_string:
            sect_match = self._SECTION_RE.match(line)
            elem_match = self._ELEMENT_RE.match(line)
            if sect_match:
                cur_section = sect_match.group('section')
                self.parsed_options.setdefault(cur_section, {})
            if elem_match:
                key = elem_match.group('key')
                val = elem_match.group('val')
                self.parsed_options[cur_section].setdefault(key, [])
                self.parsed_options[cur_section][key].append(val)
        return self


class GGitConfig():
    _SVN_REMOTE_RE = re.compile(r'svn-remote\s*"(.*)"')

    def __init__(self, dot_git):
        self.remotes = []
        self._config_parser = None
        self.dot_git = dot_git

    @classmethod
    def from_str(cls, dot_git, string):
        self = cls(dot_git)

        self._config_parser = GitConfigParser.from_string(string)

        # Find all 'svn-remote's
        for section in self._config_parser.sections():
            match = self._SVN_REMOTE_RE.search(section)
            if match:
                remote = match.group(1)
                url = self._config_parser.get(section, 'url')
                if url is None or len(url) > 1:
                    raise ValueError('git-svn remote must have single url')
                url = url[0]

                fetches = self._config_parser.get(section, 'fetch')
                if fetches is None:
                    raise ValueError('git-svn remote must have a url')

                self.remotes.append(GitSvnRemote(remote, url, fetches))

        remote_urls = {remote.url for remote in self.remotes}
        if len(remote_urls) != len(self.remotes):
            raise ValueError('Multiple git-svn remotes with '
                             'the same url is not supported')

        return self

    @classmethod
    def from_branch(cls, branch):
        git = Git.dot_git()
        try:
            config = call_output('git show %s:config' % branch,
                                 stderr=subprocess.STDOUT).rstrip()
        except subprocess.CalledProcessError as e:
            raise GGitExcpetion(Status.Error, textwrap.dedent(
                '''
                Failed to "git show {branch}:config"

                {err}

                Does the branch exist and contain the config file?
                '''
                .format(branch=branch, err=e.output)))
        return cls.from_str(git, config)

    @classmethod
    def from_dot_git(cls, dot_git):
        with open(cls.get_config_path(dot_git), 'r') as f:
            config = f.read()
        return cls.from_str(dot_git, config)

    @classmethod
    def url_to_svn_cache(cls, dot_git, url):
        # Remove the protocol from the url
        for remote_type in REMOTE_TYPES:
            if url.startswith(remote_type):
                url = url[len(remote_type):]
                break

        return os.path.join(cls.get_dot_svn_path(dot_git), url)

    @property
    def dot_svn_path(self):
        return os.path.join(self.ggit_path, 'svn')

    @property
    def ggit_path(self):
        return os.path.join(self.dot_git, 'ggit')

    @property
    def config_path(self):
        return self.get_config_path(self.dot_git)

    @staticmethod
    def get_ggit_path(dot_git):
        return os.path.join(dot_git, 'ggit')

    @classmethod
    def get_dot_svn_path(cls, dot_git):
        return os.path.join(cls.get_ggit_path(dot_git), 'svn')

    @staticmethod
    def get_config_path(dot_git):
        return os.path.join(dot_git, 'config')


class GGitConfigWriter():
    _AUTOGEN_HEAD = textwrap.dedent('''
    # {{ ggit:{version}
    # This section has been automatically modfied by ggit.
    # Take care when removing it
    '''.format(version=VERSION))

    _AUTOGEN_TAIL = textwrap.dedent('''
    # }} ggit:{version}
    '''.format(version=VERSION))

    _HEAD_RE = re.compile(r'#\s*{\s*ggit:\d+')
    _TAIL_RE = re.compile(r'#\s*}\s*ggit:\d+')

    def __init__(self, config):
        self.config = config

    def write(self, fp):
        '''Write the svn remotes using the given filepointer'''
        fp.write(self._AUTOGEN_HEAD)
        for remote in self.config.remotes:
            fp.write(str(remote))
        fp.write(self._AUTOGEN_TAIL)

    @classmethod
    def remove_old_entry(cls, fp):
        lines = []
        old_tail = old_head = None
        for idx, line in enumerate(fp):
            lines.append(line)
            if cls._HEAD_RE.search(line):
                if old_head is not None:
                    raise GGitExcpetion(Status.GitConfigError)
                old_head = idx
            if cls._TAIL_RE.search(line):
                if old_tail is not None:
                    raise GGitExcpetion(Status.GitConfigError)
                old_tail = idx

        old_idx = (old_head, old_tail)
        if not all(old_idx) and any(old_idx):
            raise GGitExcpetion(Status.GitConfigError)
        if old_tail < old_head:
            raise GGitExcpetion(Status.GitConfigError)
        if old_head:
            lines = lines[:old_head] + lines[old_tail+1:]
            # rewind file, write lines from beginning
            fp.truncate(0)
            fp.seek(0, 0)
            if lines[-1] == '\n':
                lines = lines[0:-1]
            fp.writelines(lines)


###############################################################################
#
# High level operations
#
###############################################################################

class GGit(object):
    @staticmethod
    def switch_svn(dot_git, url, rev):
        '''
        NOTE: There are a couple strange details when it comes to implementing
        a fast switch call for svn.

        One option would be to use svn switch.  There are a couple problems
        with this approach.  First, .svn doesn't do a good job of keeping a lot
        of state around, so on very different branches a switch will
        effectively be a new clone.  Second, switch is still pretty broken when
        it comes to switching svn externals across branches.  This often leads
        to a broken .svn and would confuse users.

        The second strange choice we have to deal with is the fact that
        subversion doesn't use .svn if it is a symlink. So, rather than being
        able to create a single symlink, we symlink all files in the .svn
        folder.

        The one issue that could arise with this approach is if subversion
        creates new files in the .svn folder they will be deleted on switch. We
        only maintain the folders and files from the original svn checkout.
        '''
        svn_path = GGitConfig.url_to_svn_cache(dot_git, url)

        if os.path.exists('.svn'):
            shutil.rmtree('.svn')
        # Create a .svn dir and symlink the files because subversion won't look
        # at a symlink for it's .svn dir.
        os.mkdir('.svn')
        for f in os.listdir(svn_path):
            os.symlink(os.path.join(svn_path, f), os.path.join('.svn', f))

        # Run svn update to set the revision and depth.
        forward_check_call('svn update --force --accept working'
                           ' --set-depth=infinity -r {rev}'
                           ''.format(rev=rev))
        # Run svn revert to clean to a known svn state.
        # check_call('svn revert -q -R .')

    @classmethod
    def _backup_ggit(cls, ggit_path):
        if not os.path.exists(ggit_path):
            os.mkdir(ggit_path)
        else:
            backups = os.path.join(ggit_path, 'backups')
            if not os.path.exists(backups):
                os.mkdir(backups)
            backup_dir = tempfile.mkdtemp(dir=backups)
            old_files = os.listdir(ggit_path)
            old_files = (os.path.join(ggit_path, f) for f in old_files
                         if f != 'backups')
            for f in old_files:
                shutil.move(f, backup_dir)

    @classmethod
    def setup_git_svn_config(cls, config):
        # Create a .git/ggit/ folder backing up previous contents
        cls._backup_ggit(config.ggit_path)

        # Add .svn to the .git/info/exclude folder.
        exclude = os.path.join(config.dot_git, 'info', 'exclude')
        check_call('echo .svn >> ' + exclude)

        # Write the git config file.
        writer = GGitConfigWriter(config)
        with open(os.path.join(config.dot_git, 'config'), 'r+') as fp:
            writer.remove_old_entry(fp)
            fp.seek(0, 2)
            writer.write(fp)

    @classmethod
    def setup_empty_svn(cls, config):
        '''
        Create empty svn checkout indexes for each remote in the ggit config.
        '''
        for remote in config.remotes:
            for svn_url in remote.urls:
                svn_path = GGitConfig.url_to_svn_cache(config.dot_git, svn_url)

                if os.path.lexists(svn_path):
                    shutil.rmtree(svn_path)

                with TemporaryDirectory() as td:
                    check_call('svn co --depth=empty "{url}" "{tmpdir}"'
                               .format(url=svn_url, tmpdir=td.dir))
                    shutil.copytree(os.path.join(td.dir, '.svn'), svn_path)


###############################################################################
#
# User level commands
#
###############################################################################


class Subcommand(object):
    @classmethod
    def _map_subcommand(cls, command):
        commands = {}
        for subclass in cls.__subclasses__():
            subcommand = subclass.__name__.lower()
            assert subcommand not in commands
            commands[subcommand] = subclass

        return commands[command.lower()]

    @classmethod
    def run_command(cls, command, args):
        subclass = cls._map_subcommand(command)
        return subclass().run(args)

    @classmethod
    def init_parsers(cls, subparsers):
        subclasses = cls.__subclasses__()
        for subclass in subclasses:
            subparser = subparsers.add_parser(
                subclass.__name__.lower(), help=subclass.__doc__)
            subclass().init_parser(subparser)

    def init_parser(self, parser):
        pass

    def run(self, args):
        raise NotImplementedError


class Clone(Subcommand):
    def init_parser(self, parser):
        parser.add_argument('repository')
        parser.add_argument('directory', default=None, nargs='?')
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)
        parser.add_argument('--remap', default='svn/:',
            help='Replace an svn fetch path from the gitconfig when fetching'
            ' from origin')
        parser.add_argument('--fetch-gitsvn', action='store_true')

    def run(self, args):
        repository = args['repository']
        directory = args['directory']
        config_branch = args['config_branch']
        fetch_svn = args['fetch_gitsvn']
        remap = args['remap']
        try:
            remap_src, remap_dst = remap.split(':')
        except ValueError:
            raise GGitExcpetion(Status.InvalidArguments, '--remap expects "[]:[]" ')

        if not Git.ref_exists_on_remote(repository, config_branch):
            print(textwrap.dedent(
                """
                The repository '%s' does not ggit config branch '%s'
                The branch can be set with the --config-branch optioon.
                """
                % (repository, config_branch)))
            raise GGitExcpetion(Status.NoConfigBranch)

        # If no local folder name provided, use git's naming scheme.
        if directory is None:
            directory = Git.basename(repository)

        if os.path.exists(directory):
            raise GGitExcpetion(Status.PathExists,
                                "Destination: '%s' already exists" % directory)

        forward_check_call('git clone {repo} {directory}'
                           .format(repo=repository, directory=directory))

        with Chdir(directory):
            config = Configure().run(args)

            if fetch_svn:
                branches = []
                for remote in config.remotes:
                    for branch in remote.branches:
                        branch = Git.branch_without_refs(branch)
                        remote = re.sub(remap_src, remap_dst, branch, count=1)
                        branches.append((remote, branch))

                # Setup git svn
                for (remote, local) in branches:
                    if Git.ref_exists_on_remote('origin', remote):
                        forward_check_call('git fetch origin "refs/heads/%s:'
                                           'refs/remotes/%s"'
                                           % (remote, local))
                    else:
                        print(textwrap.dedent(
                            """
                            Warning: git-svn branch '%s' doesn't exist on branch,
                            Unable to resolve fetch for '%s'
                            """ % (remote, local)))


class Switch(Subcommand):
    def init_parser(self, parser):
        parser.add_argument('hashish')
        parser.add_argument('--force', action='store_true')

    def run(self, args):
        force = args['force']
        hashish = args['hashish']
        force = '--force' if force else ''

        # Check that we are in a git repo.
        Git.enforce_in_repo()

        # Check that the working directory is clean.
        if Git.working_is_dirty() and not force:
            raise GGitExcpetion(Status.RepoIsDirty)

        if not Git.commit_exists(hashish):
            raise GGitExcpetion(
                Status.NoSuchCommit,
                "The given commit '%s' doesn't exist."
                % hashish)

        # Search the log for latest git-svn commit
        log_entry = Git.latest_svn_commit(hashish)

        if log_entry is None:
            raise GGitExcpetion(
                Status.NonSvnCommit,
                "The given commit '%s' isn't on a git-svn repository."
                % hashish)

        with Chdir(Git.toplevel()):
            # Run git checkout to complete head change.
            check_call('git checkout %s %s' % (force, hashish))

            # Check the .git/ggit/config file for the remote to .svn mapping.
            GGit.switch_svn(Git.dot_git(), log_entry.url, log_entry.revision)


class Configure(Subcommand):
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)

    def run(self, args):
        '''
        Read from the ggit-config branch and configure the git repository to
        match.
        '''
        config_branch = args['config_branch']
        # Check that we are in a git repo.
        Git.enforce_in_repo()

        branch = Git.find_branch(config_branch)
        config = GGitConfig.from_branch(branch)

        GGit.setup_git_svn_config(config)
        GGit.setup_empty_svn(config)

        # Check if the current HEAD is a git svn branch.
        log_entry = Git.latest_svn_commit('HEAD')
        if log_entry is None:
            print(NON_GIT_HEAD)
        else:
            GGit.switch_svn(config.dot_git, log_entry.url, log_entry.revision)
        return config


class Initialize(Subcommand):
    '''
    Fetch and initialize a ggit repo from an svn path.

    It's recommended to use this within a bare repo.
    '''
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)
        parser.add_argument('-r', '--revision', default='0')
        parser.add_argument('url')
        parser.add_argument('remote-names', nargs='+',
                            help='E.g. branches/ap/trunk:aptrunk')

    def _parse_remotes(self, remotes):
        fetches = {}
        for item in remotes:
            match = re.search('([^:]+):([^:]+)', item)
            if not match:
                raise ValueError('Argument incorrect format')
            fetches[match.group(2)] = match.group(1)
        return fetches

    def run(self, args):
        url = args['url']
        remotes = args['remote-names']
        rev = args['revision']
        conf_branch = args['config_branch']

        # TODO Assert user has git-svn
        fetches = self._parse_remotes(remotes)

        Git.enforce_in_repo()
        # TODO Save the original HEAD so we can restore it.

        with Chdir(Git.toplevel()):
            # If branch already exists, just checkout naturally.
            if Git.find_branch(conf_branch) is not None:
                check_call('git checkout {branch}'.format(branch=conf_branch))
            else:
                check_call('git checkout --orphan {branch}'
                           .format(branch=conf_branch))
            check_call('git reset')

            # Create our config file
            config = GGitConfig(url, fetches)
            config.write(GIT_CONFIG_FILE)

            # Check if the file is the same as the config if so, don't try
            # to commit.
            check_call('git add {config}'.format(config=GIT_CONFIG_FILE))
            if Git.staging_is_dirty():
                check_call('git commit'
                           ' -m "<ggit autocommit> Create config file"')
            else:
                check_call('git reset')

            Configure().run(args)
            check_call('git svn fetch -r {revision}:HEAD'.format(revision=rev))


class Push(Subcommand):
    '''
    Push git-svn branches and ggit-config to a remote.
    '''
    def init_parser(self, parser):
        parser.add_argument('remote')
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)
        # TODO support partial push

    def run(self, args):
        remote = args['remote']
        config_branch = args['config_branch']

        Git.enforce_in_repo()

        # Push the config branch
        local_ref = Git.find_branch(config_branch)
        forward_check_call('git push {remote}'
                           ' {local_ref}:refs/heads/{config_branch}'
                           .format(local_ref=local_ref,
                                   config_branch=config_branch,
                                   remote=remote))

        # TODO: Read the ggitconfig for branch names
        forward_check_call('git push {remote}'
                           ' "refs/remotes/{pfx}*'
                           ':refs/heads/*"'
                           .format(remote=remote,
                                   pfx=GIT_SVN_PFX))


#
# TODO Verity Works
# class GenerateIgnore(Subcommand):
#     '''Generate an ignore file'''
#
#     def init_parser(self, parser):
#         # TODO Accept optional argument of gitignroe manual file
#         pass
#
#     @staticmethod
#     def get_externs():
#         # Get a list of svn externals
#         # (Parse svn st for externals)
#         externs = []
#         changelist = call_output('svn st')
#         for line in changelist.splitlines():
#             match = re.search(r'^\s*X\s*(.*)$', line)
#             if match:
#                 externs.append(match.groups(0))
#         return externs
#
#     def run(self, args):
#         externs = self.get_externs()
#         svn_ignores = call_output('git svn show-ignore')
#         svn_ignores = filter(lambda string: not string.startswith('#'),
#                              svn_ignores.splitlines())
#         for line in sorted(set(externs) and set(svn_ignores)):
#             print(line)
#         return EXIT_CODE.SUCCESS

# TODO Command to forward args to git svn fetch
# TODO Command to forward args to git svn rebase, and run svn update afterwards
# TODO Command to create a gcrucible diff
# TODO Command to initialize a new repository with svn url and branches. (REQ)
# TODO Command to automate updating a repository with git-svn data (REQ)


def parse_args():
    parser = argparse.ArgumentParser(prog='ggit')
    subparsers = parser.add_subparsers(dest='command')
    Subcommand.init_parsers(subparsers)
    options = parser.parse_args()
    return options.command, vars(options)


def main(command, args):
    # TODO Assert user had git-svn installed.
    # Check the subparser used, pass the args to the class named after it.
    Subcommand.run_command(command, args)
    return 0


if __name__ == '__main__':
    parsed = parse_args()
    sys.exit(main(*parsed))
