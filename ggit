#!/usr/bin/python
from __future__ import print_function

import argparse
import ConfigParser
import io
import itertools
import logging
import pprint
import tempfile
import os
import re
import shutil
import sys
import subprocess
import textwrap

GIT_CONFIG_FILE = 'config'
GGIT_FOLDER = 'git-svn'
GGIT_CONFIG_BRANCH = '%s/CONFIG' % GGIT_FOLDER


class Cwd:
    def __init__(self, directory):
        self._dir = directory

    def __enter__(self):
        self._olddir = os.getcwd()
        os.chdir(self._dir)
        return self

    def __exit__(self, *args):
        if hasattr(self,'_olddir'):
            os.chdir(self._olddir)

class TemporaryDirectory(object):
    def __enter__(self):
        self.dir = tempfile.mkdtemp()
        return self

    def __exit__(self, *args):
        shutil.rmtree(self.dir)

class GitSvnConfig():
    template = '''
    [svn-remote "svn"]
        url = {url}
    {fetches}
    '''
    template = textwrap.dedent(template)
    fetch_template = ('    fetch = {remote_branch}:'
            'refs/remotes/svn/{folder}/{branch}')

    @classmethod
    def fill_template(cls, url, fetches):
        fetch_templates = []
        for (remote_branch, branch) in fetches:
            fetch_templates.append(cls.fetch_template.format(
                remote_branch=remote_branch,
                branch=branch))

        fetch_templates = '\n'.join(fetch_templates)
        return cls.template.format(url=url, folder=GGIT_FOLDER, 
                fetches=fetch_templates)

class EXIT_CODE:
    SUCCESS = 0
    SAFTEY = 1
    NO_SUCH_REF = 2
    NOT_A_REPOSITORY = 3

def create_dotsvn(svn_url):
    with TemporaryDirectory() as td:
        try:
            shutil.rmtree('.svn')
        except OSError:
            pass
        call('svn co --depth=empty "{url}" "{tmpdir}"'
                .format(url=svn_url, tmpdir=td.dir))
        call('cp -r "{tmpdir}/.svn" .svn'.format(tmpdir=td.dir))

class Git:
    @staticmethod
    def in_a_repo():
        try:
            output = call('git rev-parse --show-toplevel')
        except subprocess.CalledProcessError:
            # TODO Save of the git stderr, it has useful information about the
            # search path.
            return 'Not a git repository'
        return None

    @staticmethod
    def is_repo_missing():

    @staticmethod
    def is_dirty():
        output = call('git status --porcelain')
        return bool(output)

    @staticmethod
    def svn_url():
        svn_url = call('git svn info --url')
        svn_url = svn_url.rstrip()
        return svn_url

    @staticmethod
    def svn_initialized():
        # TODO Check return val
        call('git svn info')

    @staticmethod
    def remote_has_ref(remote, ref):
        try:
            call('git ls-remote -q --exit-code {remote} {ref}'
                    ''.format(remote=remote, ref=ref))
        except subprocess.CalledProcessError:
            return False
        return True

    @staticmethod
    def configure_git_svn(remote, config_branch):
        with open('.git/info/exclude', 'w+') as exclude:
            exclude.write('.svn\n')
        call('git show {remote}/{branch}:config >> .git/config'
                .format(remote=remote, branch=config_branch))
        call('git fetch {remote} "refs/heads/{folder}/*:'
                'refs/remotes/svn/{folder}/*"'
                .format(folder=GGIT_FOLDER, remote=remote))
        call('git svn fetch')
        svn_url = Git.svn_url()

        # Clean up old .svn cache if exists
        # Checkout svn to a temporary directory
        # Copy over the .svn
        # Update the svn repo
        # Restore files updated with the svn revert metadata bs.
        create_dotsvn(svn_url)
        rev = Git.get_revision()
        git_update(rev)


    @staticmethod
    def enforce_clean():
        if Git.is_dirty():
            print(textwrap.dedent(
                '''
                Refusing to change branches, working directory is dirty.
                Consider stashing changes:
                    git stash --include-untracked
                '''
                ))
            return False
        return True


def call(*args, **kwargs):
    if 'shell' not in kwargs:
        kwargs.setdefault('executable', 'bash')
        kwargs.setdefault('shell', True)

    pprint.pprint(('Call: ', args, kwargs), stream=sys.stderr)
    return subprocess.check_output(*args, **kwargs)


class Subcommand(object):

    @classmethod
    def _map_subcommand(cls, command):
        commands = {}
        for subclass in cls.__subclasses__():
            subcommand = subclass.__name__.lower()
            assert subcommand not in commands
            commands[subcommand] = subclass

        return commands[command.lower()]

    @classmethod
    def run_command(cls, command, args):
        subclass = cls._map_subcommand(command)
        return subclass().run(args)

    @classmethod
    def init_parsers(cls, subparsers):
        subclasses = cls.__subclasses__()
        for subclass in subclasses:
            subparser = subparsers.add_parser(subclass.__name__.lower(), 
                    help=subclass.__doc__)
            subclass().init_parser(subparser)

    def init_parser(self, parser):
        pass

    def run(self, args):
        raise NotImplemented


class Initialize(Subcommand):
    '''
    Fetch and initialize a ggit repo from an svn path.

    It's recommended to use this within a bare repo.
    '''
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)
        parser.add_argument('-r', '--revision', default='0')
        parser.add_argument('url')
        parser.add_argument('remote-names', nargs='+',
                help='E.g. branches/ap/trunk:aptrunk')

    def _parse_remotes(self, remotes):
        fetches = []
        for item in remotes:
            match = re.search('(.*):(.*)', item)
            if not match:
                raise ValueError('Argument incorrect format')
            fetches.append((match.group(1), match.group(2)))
        return fetches

    def run(self, args):
        err = Git.is_repo_missing()
        if err is not None:
            return EXIT_CODE.NOT_A_REPOSITORY

        url = args['url']
        remotes = args['remote-names']
        rev = args['revision']
        conf_branch = args['config_branch']

        fetches = self._parse_remotes(remotes)
        config = GitSvnConfig.fill_template(url, fetches)

        # TODO Check if the config branch already exists

        call('git checkout --orphan {branch}'.format(branch=conf_branch))
        call('git reset')
        with open(GIT_CONFIG_FILE, 'w') as f:
            f.write(config)
        call('git add {config}'.format(config=GIT_CONFIG_FILE))
        call('git commit -m "<ggit autocommit> Create config file"')
        # TODO Create function to idempotently add to file
        call('cat config >> .git/config')
        call('git svn fetch -r {revision}:HEAD'.format(revision=rev))


class GenerateIgnore(Subcommand):
    '''Generate an ignore file'''

    def init_parser(self, parser):
        # TODO Accept optional argument of gitignroe manual file
        pass

    @staticmethod
    def get_externs():
        # Get a list of svn externals
        # (Parse svn st for externals)
        externs = []
        changelist = call('svn st')
        for line in changelist.splitlines():
            match = re.search(r'^\s*X\s*(.*)$', line)
            if match:
                externs.append(match.groups(0))
        return externs

    def run(self, args):
        externs = self.get_externs()
        svn_ignores = call('git svn show-ignore')
        svn_ignores = filter(lambda string: not string.startswith('#'), svn_ignores.splitlines())
        for line in sorted(set(externs) and set(svn_ignores)):
            print(line)
        return EXIT_CODE.SUCCESS




# New version
def idempotent_write(fname, string):
    # Search for the start and end tags
    with open(fname, 'r') as f:
        buf = f.read()

class Git:
    @staticmethod
    def in_a_repo():
        try:
            output = check_output('git rev-parse --show-toplevel')
        except subprocess.CalledProcessError:
            # TODO Save the git stderr, it has useful information about the search path.
            return 'Not a git repository'
        return None

    @staticmethod
    def most_recent_svn_commit(hashish):
        '''
        Check the git log for the latest git-svn log entry. Return a GitSvnLogEntry
        object for the entry. If no such entry is found return None. 
        '''
        #
        # Use git log, search through the output for the most recent git-svn log
        # message.
        #
        # Return the metadata.
        return None
        return GitSvnConfig()

    @staticmethod
    def toplevel():
        output = check_output('git rev-parse --show-toplevel')
        return output

    @staticmethod
    def dot_git():
        return os.path.join(Git.toplevel, '.git')

    @staticmethod
    def basename(repository):
        base = os.path.basename(respository)
        return re.sub(r'.git$', '', base)



class GitSvnLogEntry:
    # git-svn-id: http://rtosvc/trunk/rtos@274190 d5d84855-3516-0410-9f1e-893281b4b339
    SVN_ENTRY_REGEX = re.compile(
            r'git-svn-id: (?P<url>([^@]+)@(?P<rev>\d+)'
            r' (?P<svn_uuid>[0-9a-z\-]+)')

    # commit 3505cb1adc010f7dcf18247846fe09d7353acb9c
    GIT_ENTRY_REGEX = re.compile('commit (?P<hash>[0-9a-z]+)')

    def __init__(self, url, rev, git_uuid, svn_uuid):
        self.url = url
        self.revision = rev
        self.git_hash = git_uuid
        self.git_svn_hash = svn_uuid

    @classmethod
    def find_entry(cls, line_iter):
        # Keep a running log of git hashes,
        # Since git hashes are before git-svn entries, once we find a git-svn
        # entry the most recent git hash goes with the svn entry.  
        for line in line_iter:
            git_match = cls.GIT_ENTRY_REGEX.match(line)
            svn_match = cls.SVN_ENTRY_REGEX.match(line)
            if git_match:
                git_uuid = git_match.groups(1)
            if svn_match:
                match = svn_match.groupsdict()
                match['git_uuid'] = git_uuid
                return GitSvnLogEntry(**match)
        return None


class GGitConfig():

    def __init__(self, url, branches):
        '''
        :param url: Base url of the svn respository
        :param branches: {branch: path} dictionary
        '''
        self.url = url
        self.branches = branches

    @classmethod
    def from_str(cls, string):
        parser = ConfigParser.SafeConfigParser()
        fp = io.BytesIO(string)
        parser.readfp(fp)
        sections = parser.sections()

        # Find brach.
        branches = []
        for section in sections:
            match = re.match('branch\.(.*)')
            if match:
                branches.append((match.group(0), match.group(1)))

        paths = {}
        for (section, branch) in branches:
            path = parser.get(section, 'path')
            assert path
            paths[branch] = path

        url = parser.get('base', 'url')
        assert url
        return GGitConfig(url, branches)

    @classmethod
    def from_branch(cls):
        config = check_output('git show {remote}/{branch}:config'
                .format(remote=remote, branch=config_branch))
        return cls.from_str(config)

    @classmethod
    def from_dot_git(cls):
        Git.toplevel()
        with open(Git.dot_git(), 'r') as f:
            config = f.read()
        return cls.from_str(config)

    def url_to_branch(self, url):
        '''Given the url, convert it to a branch.'''
        for branch, path  in self.branches.items():
            if url == self.url + '/' + path:
                return branch

    @staticmethod
    def get_dot_svn_path(branch):
        git = GGitConfig.get_ggit_path()
        return os.path.join(git, 'svn', branch)

    @staticmethod
    def get_ggit_path(self):
        git = Git.dot_git()
        return os.path.join(git, 'ggit')

    def switch_svn(self, url, rev):
        branch = self.url_to_bramch(url)
        # Replace the symlink .svn with one in .git/ggit/
        svn_path = self.get_dot_svn_path(branch)
        if os.path.exists('.svn'):
            os.remove('.svn')
        os.symlink(svn_path, '.svn')

        # Run svn update to set the revision and depth.
        check_call( 'svn update -q --force --accept working'
                ' --set-depth=infinity -r {rev}'
                ''.format(rev=rev))
        # Run svn revert to clean to a known svn state.
        check_call('svn revert -q -R .')

    def _backup_ggit(self):
        ggit = self.get_ggit_path()
        if not os.path.exists(ggit):
            os.mkdir(ggit)
        else:
            backups = os.path.join(ggit, 'backups')
            if not os.path.exists(backups):
                os.mkdir(backups)
            backup_dir = tempfile.mkdtemp(dir=backups)
            old_files = os.listdir(ggit)
            old_files = (f for f in old_files if f != 'backups')
            for f in old_files:
                shutil.move(f, backup_dir)

    def setup_ggit(self):
        git = Git.dot_git()
        for branch in self.branches:
            svn_path = self.get_dot_svn_path(branch)

        # Create a .git/ggit/ folder. 
        #   (Backup the previous contents if it exists.)
        self._backup_ggit()

        # Add .svn to the .git/info/exclude folder.
        exclude = os.path.join(git, 'info', 'exclude')
        check_call('echo .svn >> ' + exclude)

    def setup_git_svn(self):
        # TODO
        # Setup the .git/config fetches based on ggit-config file
        #   (Possibly replacing old version. Use a begin and end statement to mark for
        #   easy scripting.)

        # Run git svn fetch
        call('git fetch {remote} "refs/heads/{folder}/*:'
                'refs/remotes/svn/{folder}/*"'
                .format(folder=GGIT_FOLDER, remote=remote))

    def setup_empty_svn(self):
        for branch in self.branches:
            svn_path = self.get_dot_svn_path(branch)
            if os.path.exist(svn_path):
                shutil.rmtree(svn_path)

            with TemporaryDirectory() as td:
                call('svn co --depth=empty "{url}" "{tmpdir}"'
                        .format(url=svn_url, tmpdir=td.dir))
                shutil.copytree(os.path.join(td.dir, '.svn'), svn_path)


GGIT_CONFIG_BRANCH =  'ggit-config'

class Clone(Subcommand):
    NON_GIT_HEAD =  textwrap.dedent('''
            The HEAD is not pointing to a git-svn branch.
            In order to setup the correct .svn, switch branches with ggit. E.g:

                ggit switch <branch-name>
            ''')

    def init_parser(self, parser):
        pass

    def run(self, args):
        repository = args['repository']
        directory = args['directory'] # optional

        # Check that the remote has the ggit-config branch.
        check_call('git ls-remote -q --exit-code {remote} {ref}'
                .format(remote=remote, ref=ref))

        # If no local folder name provided, use git's naming scheme.
        directory = Git.basename(repository) if directory is None
        if os.path.exists(directory):
            return Status.PathExists

        check_call('git clone {repo} {directory}'
                .format(repo=repository, directory=directory))


        with CWD(directory):
            # RUN CONFIGURE
            config = Configure()

            # Create local branches for all remote git-svn branches.
            check_call('git fetch origin'
                    ' refs/remotes/origin/git-svn/*'
                    ':refs/heads/git-svn/*')


class Switch(Subcommand):
    def init_parser(self, parser):
        pass

    def run(self, args):
        force = args['force']
        hashish = args['hashish']
        # Check that we are in a git repo.
        if not Git.in_a_repo():
            return Status.NotInRepo

        # Check that the working directory is clean.
        if not Git.is_clean() and not force:
            return Status.RepoIsDirty

        log_entry = Git.latest_svn_commit(hashish)

        # Check the .git/ggit/config file for the remote to .svn mapping.
        config = GGitConfig()
        config.setup_svn(log_entry.url, log_entry.revision)

        # Run git checkout to complete.
        check_call('git checkout ' + hashish)


class Config(Subcommand):
    def init_parser(self, parser):
        pass
    def run(self, args):
        '''
        Read from the ggit-config branch and configure the git repository to match.
        '''
        # Check that we are in a git repo.
        if not Git.in_a_repo():
            return Status.NotInRepo

        # Check that the ggit-config branch exists locally or as a remote by looking
        #   in .git/refs/heads and .git/refs/remotes, if not local, but in multiple
        #   remotes fail.
        def find_config_branch():
            root = Git.toplevel()
            assert root

            matches = []
            for root, dirs, files in os.walk(os.path.join(root, '.git', 'refs')):
                for f in files:
                    name = os.path.basename(f)
                    if name == GGIT_CONFIG_BRANCH:
                        matches.append(root)

            local_config_branch = 'refs/heads' + GGIT_CONFIG_BRANCH

            if local_config_branch in matches:
                return local_config_branch
            if len(matches) > 1
                return Status.AmbiguousReference
            return matches[0]

        branch = find_config_branch()
        config = GGitConfig.from_branch(branch)

        # Create a .git/ggit/ folder. 
        #   (Backup the previous contents if it exists.)
        # Add .svn to the .git/info/exclude folder.
        config.setup_ggit()

        # Setup the .git/config fetches based on ggit-config file
        #   (Possibly replacing old version. Use a begin and end statement to mark for
        #   easy scripting.)
        # Run git svn fetch
        config.setup_git_svn()

        # Prepare the --depth=empty .svn folders within the .git/ggit/ folder
        config.setup_empty_svn()

        # Check if the current HEAD is a git svn branch. 
        log_entry = most_recent_svn_commit()
        if log_entry is None:
            print(self.NON_GIT_HEAD)
            return
        else:
            config.switch_svn(log_entry.url, log_entry.revision)


# TODO Command to create a gcrucible diff
# TODO Command to initialize a new repository with svn url and branches. (REQ)
# TODO Command to automate updating a repository with git-svn data (REQ)

def parse_args():
    parser = argparse.ArgumentParser(prog='ggit')
    subparsers = parser.add_subparsers(dest='command')
    Subcommand.init_parsers(subparsers)
    options = parser.parse_args()
    return options.command, vars(options)

def main(command, args):
    # TODO Assert user had git-svn installed.
    # Check the subparser used, pass the args to the class named after it.
    return Subcommand.run_command(command, args)

if __name__ == '__main__':
    parsed = parse_args()
    sys.exit(main(*parsed))
