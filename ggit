#!/usr/bin/python
from __future__ import print_function

import argparse
import itertools
import logging
import pprint
import tempfile
import os
import re
import shutil
import sys
import subprocess
import textwrap

GIT_CONFIG_FILE = 'config'


class Cwd:
    def __init__(self, directory):
        self._dir = directory

    def __enter__(self):
        self._olddir = os.getcwd()
        os.chdir(self._dir)
        return self

    def __exit__(self, *args):
        if hasattr(self,'_olddir'):
            os.chdir(self._olddir)

class TemporaryDirectory(object):
    def __enter__(self):
        self.dir = tempfile.mkdtemp()
        return self

    def __exit__(self, *args):
        shutil.rmtree(self.dir)

class GitSvnConfig():
    template = '''
    [svn-remote "svn"]
        url = {url}
    {fetches}
    '''
    template = textwrap.dedent(template)
    fetch_template = '    fetch = {remote_branch}:refs/remotes/svn/git-svn/{branch}\n'

    @classmethod
    def fill_template(cls, url, fetches):
        fetch_templates = []
        for (remote_branch, branch) in fetches:
            fetch_templates.append(cls.fetch_template.format(
                remote_branch=remote_branch,
                branch=branch))

        fetch_templates = '\n'.join(fetch_templates)
        return cls.template.format(url=url, fetches=fetch_templates)

class EXIT_CODE:
    SUCCESS = 0
    SAFTEY = 1
    NO_SUCH_REF = 2
    NOT_A_REPOSITORY = 3

def create_dotsvn(svn_url):
    with TemporaryDirectory() as td:
        try:
            shutil.rmtree('.svn')
        except OSError:
            pass
        call('svn co --depth=empty "{url}" "{tmpdir}"'
                .format(url=svn_url, tmpdir=td.dir))
        call('cp -r "{tmpdir}/.svn" .svn'.format(tmpdir=td.dir))

class Git:
    @staticmethod
    def is_repo_missing():
        try:
            output = call('git rev-parse --show-toplevel')
        except subprocess.CalledProcessError:
            # TODO Save of the git stderr, it has useful information about the
            # search path.
            return 'Not a git repository'
        return None

    @staticmethod
    def is_dirty():
        output = call('git status --porcelain')
        return bool(output)

    @staticmethod
    def svn_url():
        svn_url = call('git svn info --url')
        svn_url = svn_url.rstrip()
        return svn_url

    @staticmethod
    def svn_initialized():
        # TODO Check return val
        call('git svn info')

    @staticmethod
    def remote_has_ref(remote, ref):
        try:
            call('git ls-remote -q --exit-code {remote} {ref}'
                    ''.format(remote=remote, ref=ref))
        except subprocess.CalledProcessError:
            return False
        return True

    @staticmethod
    def configure_git_svn(remote, config_branch):
        with open('.git/info/exclude', 'w+') as exclude:
            exclude.write('.svn\n')
        call('git show {remote}/{branch}:config >> .git/config'
                .format(remote=remote, branch=config_branch))
        call('git fetch {remote} "refs/heads/git-svn/*:refs/remotes/svn/git-svn/*"'
                .format(remote=remote))
        call('git svn fetch')
        svn_url = Git.svn_url()

        # Clean up old .svn cache if exists
        # Checkout svn to a temporary directory
        # Copy over the .svn
        # Update the svn repo
        # Restore files updated with the svn revert metadata bs.
        create_dotsvn(svn_url)
        rev = Git.get_revision()
        git_update(rev)

    @staticmethod
    def get_revision():
        info = call('git svn info')
        match = re.search('Revision: (\d+)', info)
        assert match
        rev = match.group(1)
        return rev

    @staticmethod
    def enforce_clean():
        if Git.is_dirty():
            print(textwrap.dedent(
                '''
                Refusing to change branches, working directory is dirty.
                Consider stashing changes:
                    git stash --include-untracked
                '''
                ))
            return False
        return True


def call(*args, **kwargs):
    if 'shell' not in kwargs:
        kwargs.setdefault('executable', 'bash')
        kwargs.setdefault('shell', True)

    pprint.pprint(('Call: ', args, kwargs), stream=sys.stderr)
    return subprocess.check_output(*args, **kwargs)

def git_update(revision):
    call('svn update -q --force --accept working --set-depth=infinity -r %s'
            % revision)
    call('svn revert -q -R .')
    call('git checkout --force')

class Subcommand(object):

    @classmethod
    def _map_subcommand(cls, command):
        commands = {}
        for subclass in cls.__subclasses__():
            subcommand = subclass.__name__.lower()
            assert subcommand not in commands
            commands[subcommand] = subclass

        return commands[command.lower()]

    @classmethod
    def run_command(cls, command, args):
        subclass = cls._map_subcommand(command)
        return subclass().run(args)

    @classmethod
    def init_parsers(cls, subparsers):
        subclasses = cls.__subclasses__()
        for subclass in subclasses:
            subparser = subparsers.add_parser(subclass.__name__.lower(), 
                    help=subclass.__doc__)
            subclass().init_parser(subparser)

    def init_parser(self, parser):
        pass

    def run(self, args):
        raise NotImplemented

class Configure(Subcommand):
    '''
    Configure the current repository as a ggit-svn repository.

    This requries a config branch which contains metadata required to initialize
    a mixed git and svn repository.
    '''
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default='svn/CONFIG')
        parser.add_argument('--remote', default='origin')

    def run(self,args):
        remote = args['remote']
        conf_branch = args['config_branch']
        Git.configure_git_svn(remote, conf_branch)


class Clone(Subcommand):
    '''
    Clone a ggit repository. (A mixed git-svn, svn repo.)
    '''

    def init_parser(self, parser):
        parser.add_argument('remote')
        parser.add_argument('destination')
        parser.add_argument('--config-branch', default='svn/CONFIG')

    def run(self, args):
        remote = args['remote']
        dest = args['destination']
        conf_branch = args['config_branch']

        # Verify remote has the config_branch
        if not Git.remote_has_ref(remote, conf_branch):
            print('Remote "{remote}" does not contain configuration reference'
                ' "{ref}"'.format(remote=remote, ref=conf_branch))
            return EXIT_CODE.NO_SUCH_REF

        call('git clone --no-checkout'.split() + [remote, dest], shell=False)
        with Cwd(dest):
            Git.configure_git_svn('origin', conf_branch)

        return EXIT_CODE.SUCCESS


class Initialize(Subcommand):
    '''
    Fetch and initialize a ggit repo from an svn path.

    It's recommended to use this within a bare repo.
    '''
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default='svn/CONFIG')
        parser.add_argument('-r', '--revision', default='0')
        parser.add_argument('url')
        parser.add_argument('remote', nargs='+',
                help='E.g. branches/ap/trunk:aptrunk')

    def _parse_remotes(self, remotes):
        fetches = []
        for item in remotes:
            match = re.search('(.*):(.*)', item)
            if not match:
                raise ValueError('Argument incorrect format')
            fetches.append((match.group(1), match.group(2)))
        return fetches

    def run(self, args):
        url = args['url']
        remotes = args['remote']
        rev = args['revision']
        conf_branch = args['config_branch']

        fetches = self._parse_remotes(remotes)
        config = GitSvnConfig.fill_template(url, fetches)

        # TODO Check if the config branch already exists

        call('git checkout --orphan {branch}'.format(branch=conf_branch))
        call('git reset')
        with open(GIT_CONFIG_FILE, 'w') as f:
            f.write(config)
        call('git add {config}'.format(config=GIT_CONFIG_FILE))
        call('git commit -m "<ggit autocommit> Create config file"')
        # TODO Create function to idempotently add to file
        call('cat config >> .git/config')
        call('git svn fetch -r {revision}:HEAD'.format(revision=rev))


class Switch(Subcommand):
    '''
    Change branches and update the hidden svn repository to match the branch's
    svn revision.
    '''
    def init_parser(self, parser):
        parser.add_argument('-F', '--force', default=False, action='store_true')
        parser.add_argument('branch')
        pass

    def run(self, args):
        force = args['force']
        branch = args['branch']

        err = Git.is_repo_missing()
        if err is not None:
            return EXIT_CODE.NOT_A_REPOSITORY

        if not force and not Git.enforce_clean():
            return EXIT_CODE.SAFTEY

        # TODO Use the svn revision
        call('git checkout --detach')
        call('git reset --soft {branch}'.format(branch=branch))
        rev = Git.get_revision()

        # We have to recreate the .svn folder because 'svn switch' is buggy when
        # it comes to changing svn:externals.
        svn_url = Git.svn_url()
        create_dotsvn(svn_url)
        rev = Git.get_revision()
        git_update(rev)
        call('git checkout {branch} --force --'.format(branch=branch))
        return EXIT_CODE.SUCCESS


class Rebase(Subcommand):
    '''
    Rebase the current branch on top of a the latest fetched git-svn.
    '''
    def init_parser(self, parser):
        pass

    def run(self, args):
        call('git svn rebase')
        Sync().run(args)
        return EXIT_CODE.SUCCESS


class Pull(Subcommand):
    '''
    Fetch the latest svn changes and rebase the current branch on top of them.
    '''
    def run(self, args):
        call('git svn fetch')
        Rebase().run(args)
        return EXIT_CODE.SUCCESS


class Sync(Subcommand):
    '''
    Synchronize the .svn to the current branch's svn revision and branch.
    '''
    def init_parser(self, parser):
        parser.add_argument('-F', '--force', default=False, action='store_true')

    def run(self, args):
        force = args['force']

        if not force and not Git.enforce_clean():
            return EXIT_CODE.SAFTEY

        svn_url = Git.svn_url()
        call('svn switch --force {url}'.format(url=svn_url))
        rev = Git.get_revision()
        git_update(rev)
        return EXIT_CODE.SUCCESS


class GenerateIgnore(Subcommand):
    '''Generate an ignore file'''

    def init_parser(self, parser):
        # TODO Accept optional argument of gitignroe manual file
        pass

    @staticmethod
    def get_externs():
        # Get a list of svn externals
        # (Parse svn st for externals)
        externs = []
        changelist = call('svn st')
        for line in changelist.splitlines():
            match = re.search(r'^\s*X\s*(.*)$', line)
            if match:
                externs.append(match.groups(0))
        return externs

    def run(self, args):
        externs = self.get_externs()
        svn_ignores = call('git svn show-ignore')
        svn_ignores = filter(lambda string: not string.startswith('#'), svn_ignores.splitlines())
        for line in sorted(set(externs) and set(svn_ignores)):
            print(line)
        return EXIT_CODE.SUCCESS


def parse_args():
    parser = argparse.ArgumentParser(prog='ggit')
    subparsers = parser.add_subparsers(dest='command')
    Subcommand.init_parsers(subparsers)
    options = parser.parse_args()
    return options.command, vars(options)

def main(command, args):
    # TODO Assert user had git-svn installed.
    # Check the subparser used, pass the args to the class named after it.
    return Subcommand.run_command(command, args)

if __name__ == '__main__':
    parsed = parse_args()
    sys.exit(main(*parsed))
