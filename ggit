#!/usr/bin/python
from __future__ import print_function

import argparse
import io
import os
import pprint
import re
import shutil
import subprocess
import sys
import tempfile
import textwrap
import threading

VERSION = 0

GIT_CONFIG_FILE = 'config'
GGIT_FOLDER = 'git-svn'
GGIT_CONFIG_BRANCH = 'ggit-config'

NON_GIT_HEAD = textwrap.dedent('''
    The HEAD is not pointing to a git-svn branch.

    In order to setup a .svn folder, switch branches with ggit:

        ggit switch <branch-name>

''')
DIRTY_WORKING = textwrap.dedent('''
Refusing to change branches, working directory is dirty.

Consider stashing changes:

    git stash --include-untracked

''')

REMOTE_TYPES = {
    'file:///',
    'http://',
    'git://',
    'svn://',
    'ssh://',
}


python_version = sys.version_info
python_version = python_version[0]

class Chdir:
    def __init__(self, directory):
        self._dir = directory

    def __enter__(self):
        self._olddir = os.getcwd()
        os.chdir(self._dir)
        return self

    def __exit__(self, *args):
        if hasattr(self, '_olddir'):
            os.chdir(self._olddir)


class Status:
    NoConfigBranch = 1
    NotInRepo = 2
    PathExists = 3
    RepoIsDirty = 4
    AmbiguousReference = 5
    NoSuchCommit = 6
    NonSvnCommit = 7

    Error = 100


class GGitExcpetion(Exception):
    def __init__(self, status, msg=None):
        self.status = status
        Exception.__init__(self, msg)


class TemporaryDirectory(object):
    def __enter__(self):
        self.dir = tempfile.mkdtemp()
        return self

    def __exit__(self, *args):
        shutil.rmtree(self.dir)


def _preoprocess_call(*args, **kwargs):
    if python_version > 2:
            kwargs['universal_newlines'] = True

    if 'shell' not in kwargs:
        kwargs.setdefault('executable', 'bash')
        kwargs.setdefault('shell', True)

    kwargs.setdefault('stdout', subprocess.PIPE)
    kwargs.setdefault('stderr', subprocess.STDOUT)

    pprint.pprint(('Call: ', args, kwargs), stream=sys.stderr)
    return args, kwargs


def call_output(*args, **kwargs):
    if 'stdout' in kwargs:
        raise ValueError('stdout argument not allowed, it will be overridden.')
    args, kwargs = _preoprocess_call(*args, **kwargs)
    del kwargs['stdout']
    return subprocess.check_output(*args, **kwargs)


def check_call(*args, **kwargs):
    args, kwargs = _preoprocess_call(*args, **kwargs)
    return subprocess.check_call(*args, **kwargs)


def call_status(*args, **kwargs):
    args, kwargs = _preoprocess_call(*args, **kwargs)
    return subprocess.call(*args, **kwargs)


class Git:
    UUID_RE = '[0-9a-z]'

    @staticmethod
    def staging_is_dirty():
        ret = call_status('git diff --cached --quiet --ignore-submodules --')
        return bool(ret)

    @staticmethod
    def working_is_dirty():
        ret = call_status('git ls-files --other --directory --exclude-standard'
                          '| sed q1',
                          shell=True)
        return bool(ret)

    @staticmethod
    def is_dirty():
        return any((Git.staging_is_dirty(), Git.working_is_dirty()))

    @staticmethod
    def in_a_repo():
        try:
            Git.toplevel()
        except GGitExcpetion as e:
            return (False, e.msg)
        return (True, None)

    @staticmethod
    def enforce_in_repo():
        (status, msg) = Git.in_a_repo()
        if not status:
            raise GGitExcpetion(Status.NotInRepo, msg)

    @staticmethod
    def enforce_clean():
        if Git.is_dirty():
            raise GGitExcpetion(Status.RepoIsDirty, DIRTY_WORKING)

    @staticmethod
    def list_heads():
        output = call_output('git branch -a')
        heads = []
        for line in output.splitlines():
            heads.append(line.rstrip().lstrip())
        return heads

    @staticmethod
    def commit_exists(hashish):
        ret = call_status('git cat-file -e {hashish}^{{commit}}'
                          .format(hashish=hashish))
        return not bool(ret)

    @staticmethod
    def latest_svn_commit(hashish):
        '''
        Check the git log for the latest git-svn log entry. Return
        a GitSvnLogEntry object for the entry. If no such entry is found return
        None.
        '''
        kwargs = {
                'stdout': subprocess.PIPE,
                'stderr': subprocess.PIPE,
                'shell': False,
        }
        args = (('git log %s' % hashish).split(),)
        (args, kwargs) = _preoprocess_call(*args, **kwargs)

        git = subprocess.Popen(*args, **kwargs)
        line_iter = iter(git.stdout.readline, '')

        entry = [None]  # Use a mutable object so thread can mutate it.

        def get_entry(line_iter, entry_list):
            entry_list[0] = GitSvnLogEntry.find_entry(line_iter)

        thread = threading.Thread(target=get_entry, args=(line_iter, entry))
        thread.start()
        thread.join()
        git.communicate()

        return entry[0]

    @staticmethod
    def toplevel():
        try:
            output = call_output('git rev-parse --show-toplevel',
                                 stderr=subprocess.PIPE).rstrip()
            return output
        except subprocess.CalledProcessError as e:
            raise GGitExcpetion(Status.NotInRepo, e.msg)

    @staticmethod
    def dot_git():
        return os.path.join(Git.toplevel(), '.git')

    @staticmethod
    def basename(repository):
        base = os.path.basename(repository)
        return re.sub(r'.git$', '', base)

    @staticmethod
    def find_config_branch():
        '''
        Check that the ggit-config branch exists locally or as a remote by
        looking in .git/refs/heads and .git/refs/remotes, if not local, but in
        multiple remotes fail.
        '''
        heads = Git.list_heads()
        matches = []
        for head in heads:
            branch = Git.basename(head)
            if branch == GGIT_CONFIG_BRANCH:
                matches.append(head)

        local_config_branch = 'refs/heads/' + GGIT_CONFIG_BRANCH

        if local_config_branch in matches:
            return local_config_branch
        if len(matches) > 1:
            raise GGitExcpetion(Status.AmbiguousReference)
        if heads:
            return matches[0]


class GitSvnRemote():
    template = '''
    [svn-remote "{name}"]
    \turl = {url}
    {fetches}
    '''
    template = textwrap.dedent(template)
    fetch_template = ('\tfetch = {path}:{ref}')
    def __init__(self, name, url, fetches):
        '''
        :param url:
            Url of the svn remote to pull both git-svn and svn updates from
        :param fetches:
            A (path, ref) tuple used to configure git-svn fetching.
        '''
        self.name = name
        self.url = url

        self.fetches = []
        self.branches = []
        self.urls = []

        # Map of normalized svn path -> local fetch ref
        #self._url_map = {}
        #self._rev_url_map = {}

        for fetch in fetches:
            (path, fetch_ref) = fetch.split(':')
            self.fetches.append((path, fetch_ref))

            # TODO Do I want to remove refs/(heads)|(remotes)/
            # from branch name?
            self.branches.append(fetch_ref)
            self.urls.append(os.path.join(url, path))

            #self._rev_url_map[fetch_ref] = url
            #url = os.path.normpath(os.path.join(url, path))
            #self._url_map[url] = fetch_ref

    #def branch_to_url(self, branch):
    #    return self._rev_url_map.get(branch)

    #def url_to_branch(self, url):
    #    return self._url_map.get(os.path.normpath(url))

    def __str__(self):
        fetch_templates = []
        for (path, ref) in self.fetches:
            fetch_templates.append(self.fetch_template.format(
                path=path, ref=ref))

        fetch_templates = '\n'.join(fetch_templates)
        return self.template.format(url=self.url, name=self.name,
                                   fetches=fetch_templates)


class ConfigParserException(Exception):
    pass


class GitConfigParser(object):
    _COMMENT_RE = re.compile(r'[^#](?P<comment>#.*)$')
    _SECTION_RE = re.compile(r'\s*\[(?P<section>[^\]]*)\]')
    _ELEMENT_RE = re.compile(r'\s*(?P<key>[^=\s]*)\s*'
                             '=\s*(?P<val>[^=\s]*)\s*')

    def __init__(self):
        '''
        Options format: {section: {key: [values, ...]} }
        '''
        self.parsed_options = {}

    def __str__(self):
        lines = []
        for section, opt_keys in self.parsed_options.items():
            lines.append('[%s]' % section)
            for key, values in opt_keys:
                for value in values:
                    lines.append('%s = %s' % (key, value))
        return '\n'.join(lines)

    def sections(self):
        return iter(self.parsed_options)

    def get(self, section, key):
        section_map = self.parsed_options.get(section)
        if section_map is None:
            raise ValueError('Not such section: "%s"'
                             '\n Avaliable sections: %s' 
                             % (section, list(self.sections())))
        values = section_map.get(key)
        return values

    @classmethod
    def from_string(cls, string):
        self = GitConfigParser()
        new_string = []
        # Remove comments
        for line in string.splitlines():
            new_string.append(self._COMMENT_RE.sub('', line))

        # Assert that the section starts before an element
        for line in new_string:
            if self._SECTION_RE.search(line):
                break
            match = self._ELEMENT_RE.search(line)
            if match:
                raise ConfigParserException(
                    '%s\nElement not inside section' % match.group(0))

        cur_section = None
        for line in new_string:
            sect_match = self._SECTION_RE.match(line)
            elem_match = self._ELEMENT_RE.match(line)
            if sect_match:
                cur_section = sect_match.group('section')
                self.parsed_options.setdefault(cur_section, {})
            if elem_match:
                key = elem_match.group('key')
                val = elem_match.group('val')
                self.parsed_options[cur_section].setdefault(key, [])
                self.parsed_options[cur_section][key].append(val)
        return self


class GitSvnLogEntry:
    # git-svn-id: \
    # http://rtosvc/trunk/rtos@274190 d5d84855-3516-0410-9f1e-893281b4b339
    SVN_ENTRY_REGEX = re.compile(
            r'\s*git-svn-id:\s+(?P<url>[^@]+)@(?P<rev>\d+)'
            r'\s+(?P<svn_uuid>[0-9a-z\-]+)')

    # commit 3505cb1adc010f7dcf18247846fe09d7353acb9c
    GIT_ENTRY_REGEX = re.compile('commit (?P<hash>[0-9a-z]+)')

    def __init__(self, url, rev, git_uuid, svn_uuid):
        self.url = url
        self.revision = rev
        self.git_hash = git_uuid
        self.git_svn_hash = svn_uuid

    @classmethod
    def find_entry(cls, line_iter):
        # Keep a running log of git hashes,
        # Since git hashes are before git-svn entries, once we find a git-svn
        # entry the most recent git hash goes with the svn entry.
        for line in line_iter:
            git_match = cls.GIT_ENTRY_REGEX.match(line)
            svn_match = cls.SVN_ENTRY_REGEX.match(line)
            if git_match:
                git_uuid = git_match.groups(1)
            if svn_match:
                match = svn_match.groupdict()
                match['git_uuid'] = git_uuid
                return GitSvnLogEntry(**match)
        return None


# TODO Refactor this class.  Separate data from users of that data.
class GGitConfig():
    _SVN_REMOTE_RE = re.compile(r'svn-remote\s*"(.*)"')

    _AUTOGEN_HEAD = textwrap.dedent('''
    # {{ ggit:{version}
    # This section has been automatically modfied by ggit.
    # Take care when removing it
    '''.format(version=VERSION))

    _AUTOGEN_TAIL = textwrap.dedent('''
    # }} ggit:{version}
    '''.format(version=VERSION))


    def __init__(self):
        self.remotes = []
        self._config_parser = None

    @classmethod
    def from_str(cls, string):
        self = cls()

        self._config_parser = GitConfigParser.from_string(string)

        # Find all 'svn-remote's
        for section in self._config_parser.sections():
            match = self._SVN_REMOTE_RE.search(section)
            if match:
                remote = match.group(1)
                url = self._config_parser.get(section, 'url')
                if url is None or len(url) > 1:
                    raise ValueError('git-svn remote must have single url')
                url = url[0]

                fetches = self._config_parser.get(section, 'fetch')
                if fetches is None:
                    raise ValueError('git-svn remote must have a url')

                self.remotes.append(GitSvnRemote(remote, url, fetches))

        remote_urls = {remote.url for remote in self.remotes}
        if len(remote_urls) != len(self.remotes):
            raise ValueError('Multiple git-svn remotes with '
                             'the same url is not supported')

        return self

    @classmethod
    def from_branch(cls, branch):
        try:
            config = call_output('git show %s:config' % branch,
                                 stderr=subprocess.STDOUT).rstrip()
        except subprocess.CalledProcessError as e:
            raise GGitExcpetion(Status.Error, textwrap.dedent(
                '''
                Failed to "git show {branch}:config"

                {err}

                Does the branch exist and contain the config file?
                '''
                .format(branch=branch, err=e.output)))
        return cls.from_str(config)

    @classmethod
    def from_dot_git(cls):
        with open(cls.get_config_path(), 'r') as f:
            config = f.read()
        return cls.from_str(config)

    def write(self, fp):
        '''Write the svn remotes to the given pathname.'''
        for remote in self.remotes:
            fp.write(str(remote))

    def url_to_branch(self, url):
        for remote in self.remotes:
            branch = remote.url_to_branch(url)
            if branch:
                return branch

    #def branch_to_url(self, branch):
    #    for remote in self.remotes:
    #        branch = remote.branch_to_url(branch)
    #        if branch:
    #            return branch

    def url_to_svn_cache(self, url):
        # Remove the protocol from the url
        for remote_type in REMOTE_TYPES:
            if url.startswith(remote_type):
                url = url[len(remote_type):]
                break

        return os.path.join(self.get_dot_svn_path(), url)
    #
    #
    #
    #
    #

    #######################
    # TODO Better place for utility methods?? {{
    # Shouldn't rely on Git.dot()
    @staticmethod
    def get_dot_svn_path():
        git = GGitConfig.get_ggit_path()
        return os.path.join(git, 'svn')

    @staticmethod
    def get_ggit_path():
        git = Git.dot_git()
        return os.path.join(git, 'ggit')

    @staticmethod
    def get_config_path():
        git = Git.dot_git()
        return os.path.join(git, 'ggit', 'config')
    #
    # TODO Better place for utility methods?? }}
    #######################

    def switch_svn(self, url, rev):
        '''
        NOTE: There are a couple strange details when it comes to implementing
        a fast switch call for svn.

        One option would be to use svn switch.  There are a couple problems
        with this approach.  First, .svn doesn't do a good job of keeping a lot
        of state around, so on very different branches a switch will
        effectively be a new clone.  Second, switch is still pretty broken when
        it comes to switching svn externals across branches.  This often leads
        to a broken .svn and would confuse users.

        The second strange choice we have to deal with is the fact that
        subversion doesn't use .svn if it is a symlink. So, rather than being
        able to create a single symlink, we symlink all files in the .svn
        folder.

        The one issue that could arise with this approach is if subversion
        creates new files in the .svn folder they will be deleted on switch. We
        only maintain the folders and files from the original svn checkout.
        '''
        svn_path = self.url_to_svn_cache(url)

        if os.path.exists('.svn'):
            shutil.rmtree('.svn')
        # Create a .svn dir and symlink the files because subversion won't look
        # at a symlink for it's .svn dir.
        os.mkdir('.svn')
        for f in os.listdir(svn_path):
            os.symlink(os.path.join(svn_path, f), os.path.join('.svn', f))

        # Run svn update to set the revision and depth.
        check_call('svn update -q --force --accept working'
                   ' --set-depth=infinity -r {rev}'
                   ''.format(rev=rev))
        # Run svn revert to clean to a known svn state.
        # check_call('svn revert -q -R .')

    def _backup_ggit(self):
        ggit = self.get_ggit_path()
        if not os.path.exists(ggit):
            os.mkdir(ggit)
        else:
            backups = os.path.join(ggit, 'backups')
            if not os.path.exists(backups):
                os.mkdir(backups)
            backup_dir = tempfile.mkdtemp(dir=backups)
            old_files = os.listdir(ggit)
            old_files = (os.path.join(ggit, f) for f in old_files
                         if f != 'backups')
            for f in old_files:
                shutil.move(f, backup_dir)

    def setup_ggit(self):
        # Create a .git/ggit/ folder.
        #   (Backup the previous contents if it exists.)
        self._backup_ggit()

        # Add .svn to the .git/info/exclude folder.
        git = Git.dot_git()
        exclude = os.path.join(git, 'info', 'exclude')
        check_call('echo .svn >> ' + exclude)

        config_path = self.get_config_path()
        with open(config_path, 'w') as fp:
            self.write(fp)

    def setup_git_svn(self):
        git = Git.dot_git()

        head_re = re.compile(r'#\s*{\s*ggit:\d+')
        tail_re = re.compile(r'#\s*}\s*ggit:\d+')

        # Setup the .git/config fetches based on ggit-config file
        #   (Possibly replacing old version. Use a begin and end statement to
        #   mark for easy scripting.)
        def remove_old_entry(fp):
            lines = []
            old_tail = old_head = None
            for idx, line in enumerate(fp):
                lines.append(line)
                if head_re.search(line):
                    if old_head is not None:
                        raise GGitExcpetion(Status.GitConfigError)
                    old_head = idx
                if tail_re.search(line):
                    if old_tail is not None:
                        raise GGitExcpetion(Status.GitConfigError)
                    old_tail = idx

            old_idx = (old_head, old_tail)
            if not all(old_idx) and any(old_idx):
                raise GGitExcpetion(Status.GitConfigError)
            if old_tail < old_head:
                raise GGitExcpetion(Status.GitConfigError)
            if old_head:
                lines = lines[:old_head] + lines[old_tail+1:]
                # rewind file, write lines from beginning
                fp.truncate(0)
                fp.seek(0, 0)
                if lines[-1] == '\n':
                    lines = lines[0:-1]
                fp.writelines(lines)

        with open(os.path.join(git, 'config'), 'r+') as fp:
            remove_old_entry(fp)
            fp.seek(0, 2)
            fp.write(self._AUTOGEN_HEAD)
            self.write(fp)
            fp.write(self._AUTOGEN_TAIL)

    def setup_empty_svn(self):
        for remote in self.remotes:
            for svn_url in remote.urls:
                svn_path = self.url_to_svn_cache(svn_url)

                if os.path.lexists(svn_path):
                    shutil.rmtree(svn_path)

                with TemporaryDirectory() as td:
                    check_call('svn co --depth=empty "{url}" "{tmpdir}"'
                               .format(url=svn_url, tmpdir=td.dir))
                    shutil.copytree(os.path.join(td.dir, '.svn'), svn_path)


class Subcommand(object):
    @classmethod
    def _map_subcommand(cls, command):
        commands = {}
        for subclass in cls.__subclasses__():
            subcommand = subclass.__name__.lower()
            assert subcommand not in commands
            commands[subcommand] = subclass

        return commands[command.lower()]

    @classmethod
    def run_command(cls, command, args):
        subclass = cls._map_subcommand(command)
        return subclass().run(args)

    @classmethod
    def init_parsers(cls, subparsers):
        subclasses = cls.__subclasses__()
        for subclass in subclasses:
            subparser = subparsers.add_parser(
                subclass.__name__.lower(), help=subclass.__doc__)
            subclass().init_parser(subparser)

    def init_parser(self, parser):
        pass

    def run(self, args):
        raise NotImplementedError


class Clone(Subcommand):
    def init_parser(self, parser):
        parser.add_argument('repository')
        parser.add_argument('directory', default=None)

    def run(self, args):
        repository = args['repository']
        directory = args['directory']
        ref = GGIT_CONFIG_BRANCH

        # Check that the remote has the ggit-config branch.
        ret = call_status('git ls-remote -q --exit-code {remote} {ref}'
                          .format(remote=repository, ref=ref))
        if ret != 0:
            print("The repository '%s' does not ggit config branch '%s'"
                  % (repository, ref))
            raise GGitExcpetion(Status.NoConfigBranch)

        # If no local folder name provided, use git's naming scheme.
        if directory is None:
            directory = Git.basename(repository)

        if os.path.exists(directory):
            raise GGitExcpetion(Status.PathExists,
                                "Destination: '%s' already exists" % directory)

        check_call('git clone {repo} {directory}'
                   .format(repo=repository, directory=directory))

        with Chdir(directory):
            Configure().run(args)

            # Create local branches for all remote git-svn branches.
            #check_call('git fetch origin "refs/heads/{pfx}*:refs/heads/{pfx}*"'
            #           .format(pfx=GGIT_FOLDER))

            #TODO/FIXME
            ## Setup git svn
            #check_call('git fetch origin "refs/heads/{pfx}*'
            #           ':refs/remotes/svn/{pfx}*"'
            #           .format(pfx=GGIT_FOLDER))


class Switch(Subcommand):
    def init_parser(self, parser):
        parser.add_argument('hashish')
        parser.add_argument('--force')

    def run(self, args):
        force = args['force']
        hashish = args['hashish']
        force = '--force' if force else ''

        # Check that we are in a git repo.
        Git.enforce_in_repo()

        # Check that the working directory is clean.
        if Git.working_is_dirty() and not force:
            raise GGitExcpetion(Status.RepoIsDirty)

        if not Git.commit_exists(hashish):
            raise GGitExcpetion(
                Status.NoSuchCommit,
                "The given commit '%s' doesn't exist."
                % hashish)

        # Search the log for latest git-svn commit
        log_entry = Git.latest_svn_commit(hashish)

        if log_entry is None:
            raise GGitExcpetion(
                Status.NonSvnCommit,
                "The given commit '%s' isn't on a git-svn repository."
                % hashish)

        with Chdir(Git.toplevel()):
            # Run git checkout to complete head change.
            check_call('git checkout %s %s' % (force, hashish))

            # Check the .git/ggit/config file for the remote to .svn mapping.
            config = GGitConfig.from_dot_git()
            config.switch_svn(log_entry.url, log_entry.revision)


class Configure(Subcommand):
    def init_parser(self, parser):
        pass

    def run(self, args):
        '''
        Read from the ggit-config branch and configure the git repository to
        match.
        '''
        # Check that we are in a git repo.
        Git.enforce_in_repo()

        branch = Git.find_config_branch()
        config = GGitConfig.from_branch(branch)

        # Create a .git/ggit/ folder.
        #   (Backup the previous contents if it exists.)
        # Add .svn to the .git/info/exclude folder.
        config.setup_ggit()

        # Setup the .git/config fetches based on ggit-config file
        #   (Possibly replacing old version. Use a begin and end statement to
        #   mark for easy scripting.)
        # Run git svn fetch
        config.setup_git_svn()

        # Prepare the --depth=empty .svn folders within the .git/ggit/ folder
        config.setup_empty_svn()

        # Check if the current HEAD is a git svn branch.
        log_entry = Git.latest_svn_commit('HEAD')
        if log_entry is None:
            print(NON_GIT_HEAD)
        else:
            config.switch_svn(log_entry.url, log_entry.revision)


class Initialize(Subcommand):
    '''
    Fetch and initialize a ggit repo from an svn path.

    It's recommended to use this within a bare repo.
    '''
    def init_parser(self, parser):
        parser.add_argument('--config-branch', default=GGIT_CONFIG_BRANCH)
        parser.add_argument('-r', '--revision', default='0')
        parser.add_argument('url')
        parser.add_argument('remote-names', nargs='+',
                            help='E.g. branches/ap/trunk:aptrunk')

    def _parse_remotes(self, remotes):
        fetches = {}
        for item in remotes:
            match = re.search('([^:]+):([^:]+)', item)
            if not match:
                raise ValueError('Argument incorrect format')
            fetches[match.group(2)] = match.group(1)
        return fetches

    def run(self, args):
        url = args['url']
        remotes = args['remote-names']
        rev = args['revision']
        conf_branch = args['config_branch']

        # TODO Assert user has git-svn
        fetches = self._parse_remotes(remotes)

        Git.enforce_in_repo()
        # TODO Save the original HEAD so we can restore it.

        with Chdir(Git.toplevel()):
            # If branch already exists, just checkout naturally.
            if Git.find_config_branch() is not None:
                check_call('git checkout {branch}'.format(branch=conf_branch))
            else:
                check_call('git checkout --orphan {branch}'
                           .format(branch=conf_branch))
            check_call('git reset')

            # Create our config file
            config = GGitConfig(url, fetches)
            config.write(GIT_CONFIG_FILE)

            # Check if the file is the same as the config if so, don't try
            # to commit.
            check_call('git add {config}'.format(config=GIT_CONFIG_FILE))
            if Git.staging_is_dirty():
                check_call('git commit'
                           ' -m "<ggit autocommit> Create config file"')
            else:
                check_call('git reset')

            Configure().run(args)
            check_call('git svn fetch -r {revision}:HEAD'.format(revision=rev))


class Push(Subcommand):
    '''
    Push git-svn branches and ggit-config to a remote.
    '''
    def init_parser(self, parser):
        parser.add_argument('remote')
        # TODO support partial push

    def run(self, args):
        remote = args['remote']

        Git.enforce_in_repo()

        # Read the ggitconfig for branch names
        check_call('git push {remote}'
                   ' "refs/remotes/svn/{pfx}*'
                   ':refs/heads/{pfx}*"'
                   .format(remote=remote))

        local_ref = Git.find_config_branch()
        check_call('git push {remote} {local_ref}:refs/heads/{config_branch}'
                   .format(local_ref=local_ref,
                           pfx=GGIT_FOLDER,
                           config_branch=GGIT_CONFIG_BRANCH,
                           remote=remote))

#
# TODO Verity Works
# class GenerateIgnore(Subcommand):
#     '''Generate an ignore file'''
#
#     def init_parser(self, parser):
#         # TODO Accept optional argument of gitignroe manual file
#         pass
#
#     @staticmethod
#     def get_externs():
#         # Get a list of svn externals
#         # (Parse svn st for externals)
#         externs = []
#         changelist = call_output('svn st')
#         for line in changelist.splitlines():
#             match = re.search(r'^\s*X\s*(.*)$', line)
#             if match:
#                 externs.append(match.groups(0))
#         return externs
#
#     def run(self, args):
#         externs = self.get_externs()
#         svn_ignores = call_output('git svn show-ignore')
#         svn_ignores = filter(lambda string: not string.startswith('#'),
#                              svn_ignores.splitlines())
#         for line in sorted(set(externs) and set(svn_ignores)):
#             print(line)
#         return EXIT_CODE.SUCCESS

# TODO Command to forward args to git svn fetch
# TODO Command to forward args to git svn rebase, and run svn update afterwards
# TODO Command to create a gcrucible diff
# TODO Command to initialize a new repository with svn url and branches. (REQ)
# TODO Command to automate updating a repository with git-svn data (REQ)


def parse_args():
    parser = argparse.ArgumentParser(prog='ggit')
    subparsers = parser.add_subparsers(dest='command')
    Subcommand.init_parsers(subparsers)
    options = parser.parse_args()
    return options.command, vars(options)


def main(command, args):
    # TODO Assert user had git-svn installed.
    # Check the subparser used, pass the args to the class named after it.
    Subcommand.run_command(command, args)
    return 0


if __name__ == '__main__':
    parsed = parse_args()
    sys.exit(main(*parsed))
